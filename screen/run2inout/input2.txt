Brewing Java: A Tutorial

Copyright 1995-1998, 2000-2002, 2004-2006 Elliotte Rusty Harold
elharo@metalab.unc.edu
Last-modified: 2005/07/19
URL: http://www.cafeaulait.org/javatutorial.html

This tutorial has grown into a book called The Java Developer's Resource, available now from Prentice Hall. It's now out of print, but the examples and exercises from that book are also online here and may be of use. For more details about the JDR including the plans for a second edition see the JDR page.

June 3, 2006
Minor corrections on array dimensions
July 19, 2005
Improve naming conventions in examples
June 26, 2004
Fix a typo and make some efforts (incomplete) toward well-formedness
January 2, 2002
Fix a typo and URLs
February 8, 2001
Minor bug fix
January 6, 2001
Some minor changes about = and :=
May 23, 2000
Fixed a few typos.
April 23, 2000
Fixed a few bugs.
September 7, 1998
Fixed a few typos
June 23, 1998
Very minor corrections and updates
April 8, 1997
This tutorial covers Java 1.0. I've also posted several hundred pages of lecture notes from an Introduction to Java Programming course I'm teaching at Polytechnic University. These notes cover Java 1.1 extensively, and cover many more topics than are discussed here.
March 3, 1997
I've fixed a number of typos.
November 13, 1996
I've improved the treatment of recursion, expanded and updated the installation and getting started instructions, fixed a bug in the Mondrian programs, and cleaned up some other parts.
September 20, 1996
I fixed a bug in the Arg method of the complex class. Arguments in all quadrants are now handled properly. I've also fixed a few other minor bugs in various programs.
March 26, 1996
The RAM config program, typewriter applet, Bozo sort algorithm and Java doodle applet are finally included.

March 25, 1996
I recently completed my first book which grew out of this tutorial. It should be out in a few months. This file is mostly just a rough draft for some sections of that book. The book will be much improved over the very rough material you see here. If you don't like this page, you may still like the book. If you do like this page, you should love the book.
I'm now left in something of a quandary. How should I best update this tutorial? On the one hand it would be easiest to just slap the 400 pages I wrote for the book onto the web. However that would make my publisher very unhappy. On the other hand I don't feel like duplicating all my work for the book.

What I've decided to do is to try and clean this tutorial up by fixing the various mistakes, but not to add much new material to it. For instance the last fix to the ComplexNumber class broke multiplication. It is now working again. I've also fixed a lot of other random mistakes. Finally you'll notice that almost all the unwritten sections have been deleted. At this point if something's in the table of contents, then it's probably actually here.

Don't despair, though. I'm going to be writing a series of shorter articles on various topics that I either didn't cover in the book, or don't think I covered as well as I could have. Planned topics include

Why Java is different from C++
An Introduction to classes through complex numbers
Linked lists
Sparse arrays
Working with Strings
Java Tokens
Java Data types
Bitwise operators
Calling Native Code
Inf, NaN and all that: IEEE 754 arithmetic
Images and the Mandelbrot Set
Furthermore the book includes a substantial number of exercises. However it does not include answers. I am going to be posting those exercises here along with detailed explanations and answers. In this way I hope to fill out some more topics than I would have time to do in a straight tutorial fashion.

Finally I will be putting most of the source code from the book online as well. This will provide a series of useful examples.

Thus there will be a lot more new tutorial here. However this tutorial is mostly complete. There's certainly more it could cover, but I just decided I didn't want to write the same book twice.

February 7, 1996
Fixed some errors in the ComplexNumber class. DivideBy now works and toString() gives more aesthetic results when the imaginary part of a number is negative.

January 25, 1996
Polished up some of the EventTutor applets. Lesson of the day: You have to add your components to your layout.

January 24, 1996
Finished the Middle Third Applet. Lesson of the day: Casting is not the same as rounding.

January 18, 1996
Fixed assorted long standing errors.

January 16, 1996
Substantially improved Complex number class and examples.
Almost all code and most text is now beta compliant
Added change history.
This is a Java tutorial in progress. A Java FAQ list is being developed as simultaneously as time permits.

Yes, I plan to split this file into smaller chunks that are easier for browsers to digest. However right now this is an early development version of this material, and ease of writing and maintenance leads me to want to keep this file in one piece. When the outline settles down I will break it up.

It isn't all here yet, but I hope to fill this out quickly. The chapter on basic Java syntax is reaching completion. I will update this as time permits. If you find any mistakes, please do inform me.

Comments you might have on the structure, organization or contents of this document are appreciated. Although a lot remains to be fleshed out, the basic structure is as follows:

Part 1 is a brief introduction to what Java is, why it's cool and what you need to use it.

Part 2 is a tutorial introduction to Java that just covers what you need to know to start programming command line applications in Java. This is an introduction to the basic syntax of the language. It skims over many details and completely omits little used features like bit-shift operators. This section is fairly complete.

Part 3 covers the basics of writing applets in Java.

Part 4 introduces you to objects and classes.

Table of Contents

Part 1: Why Java's Cool
Installing Java
Windows Installation Instructions
Unix Installation Instructions
Running Your First Applet
Applets in Netscape
Part 2:The Syntax
Hello World: The Application
Examining Hello World
Braces and Blocks
Comments
Data and Variables
Command Line Arguments
If
Else
Variables and Arithmetic Expressions
Classes and Objects: A First Look
Interfaces
FahrToCelsius
Floating Point Variables
The For Statement
Assignment, Increment and Decrement Operators
Methods
Recursive Methods
Arrays
Creating Arrays
Counting Digits
Two Dimensional Arrays
Multidimensional Arrays
Unbalanced Arrays
Searching
Sorting
Catching Exceptions
File I/O and Streams
Interactively communicating with the user
Reading Numbers
Reading Formatted Data
Writing a text file
Reading a text file
Summing Up
Part 3: Applets
Hello World: The Applet
Examining the Hello World Applet
The APPLET HTML Tag
Passing Parameters to Applets
Events and Applets
Event Tutor Applet
Making a List
The Events
Drawing Text
Drawing Graphics: Lines, Circles, Rectangles and Colors
Drawing Rectangles
Drawing Lines
Taking Action: Threads
Bozo Sort
Interaction: Mouse and Keyboard Input
Mouse Input: Java Doodle
Keyboard Input: TypeWriter
Part 4: Objects, Classes, Methods, and Interfaces
What is Object Oriented Programming?
The History of Programming
Classes and Objects
Methods
Some Advocacy
A Non-Trivial Examples: Complex Numbers
toString Methods
Polymorphism
Scope: Calling the Complex Class From External Classes
The Mandelbrot Set
Acknowledgements
Part 1: Why Java's Cool

Java has caused more excitement than any development on the Internet since Mosaic. Everyone, it seems, is talking about it. Unfortunately very few people seem to know anything about it. This tutorial is designed to change that.

People are excited about Java because of what it lets them do. Java was the first way to include inline sound and animation in a web page. Java also lets users interact with a web page. Instead of just reading it and perhaps filling out a form, users can now play games, calculate spreadsheets, chat in realtime, get continuously updated data and much, much more.

Here are just a few of the many things Java can do for a web page:

Inline sounds that play in realtime whenever a user loads a page
Music that plays in the background on a page
Cartoon style animations
Realtime video
Multiplayer interactive games
However Java is more than just a web browser with special features. All of these features can be integrated into browsers in other ways. Although HotJava was the first browser to include inline sound and animation, Microsoft's Internet Explorer 2.0 and Netscape Navigator 2.0 support these features in several different ways. What makes Java special?

Java is a programming language for distributed applications. It doesn't just allow you to add new types of content to your pages like Netscape and Internet Explorer do. Rather it lets you add both the content and the code necessary to interact with that content. You no longer need to wait for the next release of a browser that supports your preferred image format or special game protocol. With Java you send browsers both the content and the program necessary to view this content at the same time!

Let's think about what this means for a minute. Previously you had to wait for all the companies that make the web browsers your readers use to update their browsers before you could use a new content type. Then you had to hope that all your readers actually did update their browsers. Java compatibility is a feature that any browser can implement and by so doing implement every feature!

For instance let's say you want to use EPS files on your Web site. Previously you had to wait until at least one web browser implemented EPS support. Now you don't wait. Instead you can write your own code to view EPS files and send it to any client that requests your page at the same time they request the EPS file.

Or suppose you want people to be able to search your electronic card catalog. However the card catalog database exists on a mainframe system that doesn't speak HTTP. Before Java you could hope that some browser implemented your proprietary card catalog protocol; (fat chance) or you could try to program some intermediate cgi-bin on a UNIX box that can speak HTTP and talk to the card catalog, not an easy task. With Java when a client wants to talk to your card catalog you can send them the code they need to do so. You don't have to try to force things through an httpd server on port 80 that were never meant to go through it.

If that were all Java was, it would still be more interesting than a <marquee> or <frame> tag in some new browser beta. But there's a lot more. Java is platform independent. A Java program can run equally well on any architecture that has a Java enabled browser. With the release of Netscape Navigator 2.0 that includes Windows 95, Windows NT, the MacOS, Sun Solaris, Sun OS 4.1.3, SGI IRIX, OSF/1, HP-UX with more to come. But wait. There's more!

Java isn't just for web sites. Java is a programming language that lets you do almost anything you can do with a traditional programming langauge like Fortran or C++. However Java has learned from the mistakes of its predecessors. It is considerably cleaner and easier to use than those languages.

As a language Java is

Simple
Java has the bare bones functionality needed to implement its rich feature set. It does not add lots of syntactic sugar or unnecessary features.
Object-Oriented
Almost everything in Java is either a class, a method or an object. Only the most basic primitive operations and data types (int, for, while, etc.) are at a sub-object level.
Platform Independent
Java programs are compiled to a byte code format that can be read and run by interpreters on many platforms including Windows 95, Windows NT, and Solaris 2.3 and later.
Safe
Java code can be executed in an environment that prohibits it from introducing viruses, deleting or modifying files, or otherwise performing data destroying and computer crashing operations.
High Performance
Java can be compiled on the fly with a Just-In-Time compiler (JIT) to code that rivals C++ in speed.
Multi-Threaded
Java is inherently multi-threaded. A single Java program can have many different things processing independently and continuously.
Installing Java

As of this writing Java is not a fully developed commercial product. Versions of Java at varying stages of completion are available from Sun for Windows 95 and Windows NT for X86, Solaris 2.3 to 2.5, and MacOS 7.5. At the present time there are no versions of Java available for MIPS, Alpha or PowerPC based NT, Windows 3.1, or the Amiga.

Borland is also working a Java development environment to be released in the first half of 1996. Various third-party efforts are under way to port Java to other platforms including the Amiga, Windows 3.1, OS/2 and others.

The basic Java environment consists of a web browser that can play Java applets, a Java compiler to turn to Java source code into byte code, and a Java interpreter to run Java programs. These are the three key components of a Java environment. You'll also need a text editor like Brief or BBEdit. Other tools like a debugger, a visual development environment, documentation and a class browser are also nice but aren't absolutely necessary.

Note that it isn't necessary to get all three of these from the same source. For instance Netscape is committed to providing a Java-enabled web browser. However it will only provide a Java compiler with the next version of its server products.

Sun has made the Java Developers Kit available for its supported platforms. It includes an applet viewer that will let you view and test your applets. The JDK also includes the javac compiler, the java interpreter, the javaprof profiler, the javah header file generator (for integrating C into your Java code), the Java debugger and limited documentation. However most of the documentation for the API and the class library is on Sun's web site.

You can ftp the programs from the following sites:

USA
ftp://ftp.javasoft.com/pub/
ftp://www.blackdown.org/pub/Java/pub/
ftp://ftp.science.wayne.edu/pub/java/
ftp://metalab.unc.edu/pub/languages/
ftp://java.dnx.com/pub/
Germany: ftp://sunsite.informatik.rwth-aachen.de/pub/mirror/java.sun.com/JDK-beta-win32-x86.exe
Korea: ftp://ftp.kaist.ac.kr/pub/java/e
China: ftp://math01.math.ac.cn/pub/sunsite
Japan: ftp://ftp.glocom.ac.jp/mirror/java.sun.com/
Sweden: ftp://ftp.luth.se/pub/infosystems/www/hotjava/pub/
Singapore: ftp://ftp.iss.nus.sg/pub/java/
United Kingdom: ftp://sunsite.doc.ic.ac.uk/packages/java/
Macintosh Installation Instructions

The file you get will be a self-extracting archive called something like JDK-1_0_2-MacOS.sea.bin. If you use Fetch or Anarchie to download it will be automatically converted into the self-extracting JDK-1_0_2-MacOS.sea. Double-click it to extract it and the double-click the resulting installer JDK-1_0_2-MacOS. It will prompt you for a location to put it on your hard disk. Put it wherever is convenient.

It may be helpful to make aliases of the Applet Viewer, the Java Compiler and the Java Runner and put them on your desktop for ease of dragging and dropping later, especially if you have a large monitor.

Windows Installation Instructions

The Windows X86 release is a self extracting archive. You will need about six megabytes of free disk space to install the JDK. Execute the file by double-clicking on it in the File Manager or by selecting Run... from the Program Manager's File menu and typing the path to the file. This will unpack the archive. The full path is unimportant, but for simplicity's sake I am going to assume you installed it from the root of your C: drive. If this is the case the files will live in C:\java. If you unpacked it somewhere else just replace C:\ by the full path to the java directory in what follows.

You will need to add C:\java\bin directory to your PATH environment variable

In addition to the java files, the archive includes two common DLL's:

MSVCRT20.DLL
MFC30.DLL
These two files will be installed in your java directory. If you do not already have copies of these two files on your system, (There's a very good chance you do, probably in your system directory.) copy them into the C:\java\bin directory. If you do have these two files already, just delete these extra copies.
Unix Installation Instructions

If you're on a shared system at a university or an Internet service provider, there's a good chance Java is already installed. Ask your local support staff how to access it. Otherwise follow these instructions.

The Unix release is a compressed tar file. You will need about nine megabytes of disk space to uncompress and untar the JDK. Double that would be very helpful. You do this with the commands:

% uncompress JDK-1_0_2-solaris2-sparc.tar.Z
% tar xvf JDK-1_0_2-solaris2-sparc.tar
The exact file name may be a little different if you?re retrieving the release for a different platform such as Irix or if the version is different. You can untar it in your home directory, or, if you have root privileges, in some convenient place like /usr/local where all users can have access to the files. However root privileges are not necessary to install or run Java. Untarring the file creates all necessary directories and sub-directories. The exact path is unimportant, but for simplicity's sake this book assumes it?s installed it in /usr/local. If a sysop already installed it, this is probably where it lives. (Under Solaris it's also possible the sysop put it into /opt.) If this is the case the files live in /usr/local/java. If you unpacked it somewhere else, just replace /usr/local by the full path to the java directory in what follows. If you installed it in your home directory, you can use ~/java and ~/hotjava instead of a full path.

You now need to add /usr/local/java/bin directory to your PATH environment variable. You use one of the following commands depending on your shell.

csh, tcsh: 
	% set path=($PATH /usr/local/java/bin)
sh: 
	% PATH=($PATH /usr/local/java/bin); export $PATH
You should also add these lines to the end of your .profile and .cshrc files so you won't have to do this every time you login. Now you're ready to run some applets.

Running Your First Applet

Unix Instructions

Start the Applet Viewer by doing the following:

Open a command line prompt, and cd to one of the directories in /usr/local/java/demo, for example
% cd /usr/local/java/demo/TicTacToe 
Run the appletviewer on the html file:
% appletviewer example1.html 
Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win.
Macintosh Instructions

Start the Applet Viewer by double-clicking it.
Select Open... from the File menu and navigate into the java folder, then the Sample Applets folder, then the TicTacToe folder.
Select the file example1.html and click on the Open button. Alternately you can drag and drop this file onto the Applet Viewer.
Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win.
Windows Instructions

Start the Applet Viewer by doing the following:
Open a DOS window, and cd to one of the directories in C:\JAVA\DEMO, for example
C:< cd C:\JAVA\DEMO\TicTacToe 
Run the appletviewer on the html file:
C:< appletviewer example1.htm 
Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win.
Hot Tip: Getting Rid of that Annoying License Dialog Box

Do you know the annoying dialog box I'm talking about? I bet you do. It's the one that comes up every time you launch the applet viewer to make you agree to Sun's license. Do you want to get rid of it? If so make a directory called .hotjava in your java/bin directory. You won't see it again.

Applets in Netscape

Netscape 3.0 will run Java applets on most platforms except Windows 3.1. Netscape has a Java Demo Page with links to various applets that will mostly run. However do not be surprised if an applet fails to work properly in Netscape.

Part 2:The Syntax

Hello World: The Application

At least since the first edition of Kernighan and Ritchie's The C Programming Language it's been customary to begin programming tutorials and classes with the "Hello World" program, a program that prints the string "Hello World" to the display. Being heavily influenced by Kernighan and Ritchie and not ones to defy tradition we begin similarly.

The following is the Hello World Application as written in Java. Type it into a text file or copy it out of your web browser, and save it as a file named HelloWorld.java.

class HelloWorld {

  public static void main (String args[]) {

    System.out.println("Hello World!");

  }
  
}
To compile this program make sure you're in the same directory HelloWorld.java is in and type javac HelloWorld.java at the command prompt. Hello World is very close to the simplest program imaginable. Although it doesn't teach very much from a programming standpoint, it gives you a chance to learn the mechanics of writing and compiling code. If you're like me your first effort won't compile, especially if you typed it in from scratch rather than copying and pasting. Here are a few common mistakes:

Did you put a semicolon after System.out.println("Hello World")?
Did you include the closing bracket?
Did you type everything exactly as it appears here? In particular did you use the same capitalization? Java is case sensitive. class is not the same as Class for example.
Were you in the same directory as HelloWorld.java when you typed javac HelloWorld.java?
Once your program has compiled successfully, the compiler places the executable output in a file called HelloWorld.class in the same directory as the source code file. You can then run the program by typing java HelloWorld at the command prompt. As you probably guessed the program responds by printing Hello World! on your screen.

Congratulations! You've just written your first Java program!

Examining Hello World

Hello World is very close to the simplest program imaginable. Nonetheless there's quite a lot going on in it. Let's investigate it, line by line.

For now the initial class statement may be thought of as defining the program name, in this case HelloWorld. The compiler actually got the name for the class file from the class HelloWorld statement in the source code, not from the name of the source code file. If there is more than one class in a file, then the Java compiler will store each one in a separate .class file. For reasons we'll see later it's advisable to give the source code file the same name as the main class in the file plus the .java extension.

The initial class statement is actually quite a bit more than that since this "program" can be called not just from the command line but also by other parts of the same or different programs. We'll see more in the section on classes and methods below.

The HelloWorld class contains one method, the main method. As in C the main method is where an application begins executing. The method is declared public meaning that the method can be called from anywhere. It is declared static meaning that all instances of this class share this one method. (If that last sentence was about as intelligible as Linear B, don't worry. We'll come back to it later.) It is declared void which means, as in C, that this method does not return a value. Finally we pass any command line arguments to the method in an array of Strings called args. In this simple program there aren't any command line arguments though.

Finally when the main method is called it does exactly one thing: print "Hello World" to the standard output, generally a terminal monitor or console window of some sort. This is accomplished by the System.out.println method. To be more precise this is accomplished by calling the println() method of the static out field belonging to the System class; but for now we'll just treat this as one method.

One final note: unlike the printf function in C the System.out.println method does append a newline at the end of its output. There's no need to include a \n at the end of each string to break a line.

Exercises

What happens if you change the name of the source code file, e.g. HelloEarth.java instead of HelloWorld.java?
What happens if you keep the name of the source code file the same (HelloWorld.java) but change the class's name, e.g. class HelloEarth?
Braces and Blocks

Let's investigate the Hello World program a little more closely. In Java a source code file is broken up into parts separated by opening and closing braces, i.e. the { and } characters. Everything between { and } is a block and exists more or less independently of everything outside of the braces.

Blocks are important both syntactically and logically. Without the braces the code wouldn't compile. The compiler would have trouble figuring out where one method or class ended and the next one began. Similarly it would be very difficult for someone else reading your code to understand what was going on. For that matter it would be very difficult for you, yourself to understand what was going on. The braces are used to group related statements together. In the broadest sense everything between matching braces is executed as one statement (though depending not necessarily everything inside the braces is executed every time).

Blocks can be hierarchical. One block can contain one or more subsidiary blocks. In this case we have one outer block that defines the HelloWorld class. Within the HelloWorld block we have a method block called "main".

In this tutorial we help to identify different blocks with indentation. Every time we enter a new block we indent our source code by two spaces. When we leave a block we deindent by two spaces. This is a common convention in many programming languages. However it is not part of the language. The code would produce identical output if we didn't indent it. In fact I'm sure you'll find a few examples here where I haven't followed convention precisely. Indentation makes the code easier to read and understand, but it does not change its meaning.

Comments

Comments can appear anywhere in a source file. Comments are identical to those in C and C++. Everything between /* and */ is ignored by the compiler and everything on a line after two consecutive slashes is also thrown away. Therefore the following program is, as far as the compiler is concerned, identical to the first one:

// This is the Hello World program in Java
class HelloWorld {

    public static void main (String args[]) {
      /* Now let's print the line Hello World */
      System.out.println("Hello World");
      
  }

}
Data and Variables

Methods are only half of a Java class. The other half is data. Consider the following generalization of the HelloWorld program:

// This is the Hello Rusty program in Java
class HelloRusty {

    public static void main (String args[]) {
    
      // You may feel free to replace "Rusty" with your own name
      String name = "Rusty";
      
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(name);
  }

}
Here, rather than saying hello to a rather generic world, we allow Java to say hello to a specific individual. We do this by creating a String variable called "name" and storing the value "Rusty" in it. (You may, of course, have replaced Rusty with your own name.) Then we print out "Hello ". Notice that we've switched here from System.out.println method to the similar System.out.print method. System.out.print is just like System.out.println except that it doesn't break the line after it's finished. Therefore when we reach the next line of code, the cursor is still located on the same line as the word "Hello" and we're ready to print out the name.

Command Line Arguments

Our Hello program still isn't very general. We can't change the name we say hello to without editing and recompiling the source code. This may be fine for the programmers, but what if the secretaries want their computers to say Hello to them? (I know. This is a little far-fetched but bear with me. I'm making a point.)

What we need is a way to change the name at runtime rather than at compile time. (Runtime is when we type java HelloRusty. Compile time is when we type javac HelloRusty.java). To do this we'll make use of command-line arguments. They allow us to type something like Java Hello Gloria and have the program respond with "Hello Gloria". Here's the code:

// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(args[0]);
  }

}
Compile this program in the javahtml directory as usual and then type java Hello Gloria.
This isn't very hard is it? In fact we've even gotten rid of the name variable from the HelloRusty program. We're using args[0] instead. args is what is known as an array. An array stores a series of values. The values can be Strings as in this example, numbers, objects or any other kind of Java data type.

args is a special array that holds the command line arguments. args[0] holds the first command line argument. args[1] holds the second command line argument, args[2] holds the third command line argument and so on.

At this point almost everyone reading this is probably saying "Whoa, that can't be right." However why you're saying depends on your background.

If you've never programmed before or if you've programmed only in Pascal or Fortran, you're probably wondering why the first element of the array is at position 0, the second at position 1, the third at position 2 instead of the clearly more sensible element 1 being the first element in the array, element 2 being the second and so on. All I can tell you is that this is a holdover from C where this convention almost made sense.

On the other hand if you're used to C you're probably upset because args[0] is the first command line argument instead of the command name. The problem is that in Java it's not always clear what the command name is. For instance in the above example is it java or Hello? On some systems where Java runs there may not even be a command line, the Mac for example.

Now you should experiment with this program a little. What happens if instead of typing java Hello Gloria you type java Hello Gloria and Beth? What if you leave out the name entirely, i.e. java Hello?

That was interesting wasn't it? You should have seen something very close to

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException at Hello.main(C:\javahtml\Hello.java:7)

What happened was that since we didn't give Hello any command line arguments there wasn't anything in args[0]. Therefore Java kicked back this not too friendly error message about an "ArrayIndexOutOfBoundsException." That's a mouthful. We'll see one way to fix it in the next section.

If

All but the most trivial computer programs need to make decisions. They need to test some condition and operate differently based on that condition. This is quite common in real life. For instance you stick your hand out the window to test if it's raining. If it is raining then you take an umbrella with you. If it isn't raining then you don't.

All programming languages have some form of an if statement that allows you to test conditions. In the previous code we should have tested whether there actually were command line arguments before we tried to use them.

All arrays have lengths and we can access that length by referencing the variable arrayname.length. (Experienced Java programmers will note that this means that the array is an object which contains a public member variable called length.) We test the length of the args array as follows:

// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length > 0) {
        System.out.println(args[0]);
      }
  }

}
Compile and run this program and toss different inputs at it. You should note that there's no longer an ArrayIndexOutOfBoundsException if you don't give it any command line arguments at all.
What we did was wrap the System.out.println(args[0]) statement in a conditional test, if (args.length > 0) { }. The code inside the braces, System.out.println(args[0]), now gets executed if and only if the length of the args array is greater than zero. In Java numerical greater than and lesser than tests are done with the > and < characters respectively. We can test for a number being less than or equal to and greater than or equal to with <= and >= respectively.

Testing for equality is a little trickier. We would expect to test if two numbers were equal by using the = sign. However we've already used the = sign to set the value of a variable. Therefore we need a new symbol to test for equality. Java borrows C's double equals sign, ==, to test for equality.

It's not uncommon for even experienced programmers to write == when they mean = or vice versa. In fact this is a very common cause of errors in C programs. Fortunately in Java, you are not allowed to use == and = in the same places. Therefore the compiler can catch your mistake and make you fix it before you run the program.

All conditional statements in Java require boolean values, and that's what the ==, <, >, <=, and >= operators all return. A boolean is a value that is either true or false. Unlike in C booleans are not the same as ints, and ints and booleans cannot be cast back and forth. If you need to set a boolean variable in a Java program, you have to use the constants true and false. false is not 0 and true is not non-zero as in C. Boolean values are no more integers than are strings.

Experienced programmers may note that there was an alternative method to deal with the ArrayIndexOutOFBoundsException involving try and catch statements. We'll return to that soon.

Else

You may have noticed a minor cosmetic bug in the previous program. A cosmetic bug is one that doesn't crash the program or system, or produce incorrect results, but just looks a little annoying. Cosmetic bugs are acceptable in quick hacks you'll only use once but not in finished code.

The cosmetic bug here was that if we didn't include any command line arguments, although the program didn't crash, it still didn't say Hello. The problem was that we only used System.out.print and not System.out.println. There was never any end of line character. It was like we typed in what we wanted to say, but never hit the return key.

We could fix this by putting a System.out.println(""); line at the end of the main method, but then we'd have one too many end-of-lines if the user did type in a name. We could add an additional if statement like so:

// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length > 0) {
        System.out.println(args[0]);
      }
      if (args.length <= 0) {
        System.out.println("whoever you are");
      }
  }

}
This corrects the bug, but the code is hard to read and maintain. It's very easy to miss a possible case. For instance we might well have tested to see if args.length were less than zero and left out the more important case that args.length equals zero. What we need is an else statement that will catch any result other than the one we hope for, and luckily Java provides exactly that. Here's the right solution:
// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length > 0) {
        System.out.println(args[0]);
      }
      else {
        System.out.println("whoever you are");
      }
  }

}
Now that Hello at least doesn't crash with an ArrayIndexOutOfBoundsException we're still not done. java Hello works and Java Hello Rusty works, but if we type java Hello Elliotte Rusty Harold, Java still only prints Hello Elliotte. Let's fix that.
We're not just limited to two cases though. We can combine an else and an if to make an else if and use this to test a whole range of mutually exclusive possibilities. For instance here's a version of the Hello program that handles up to four names on the command line:

// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length == 0) {
        System.out.print("whoever you are");
      }
      else if (args.length == 1) {
        System.out.println(args[0]);
      }
      else if (args.length == 2) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
      }      
      else if (args.length == 3) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
      }      
      else if (args.length == 4) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
        System.out.print(" ");
        System.out.print(args[3]);
      }      
      else {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
        System.out.print(" ");
        System.out.print(args[3]);
        System.out.print(" and all the rest!");
       }
      System.out.println();
  }

}
You can see that this gets mighty complicated mighty quickly. Once again no experienced Java programmer would write code like this. One of the things that makes this solution so unwieldy is that I've used a different print statement for every single variable. However Java makes it very easy to print multiple items at once. Instead of including just one thing in the print method's arguments we put multiple items in there separated by + signs. These items can include variables like args[0] and constant strings like " and all the rest!". For example the last else block could have been written as
else {
  System.out.print(args[0] + " " + args[1] + " " + args[2] + " " + args[3] + " and all the rest!");
}
This syntax is simpler to read and write but would still be unwieldy once the number of command line arguments grew past ten or so. In the next section we'll see how to handle over two billion command line arguments in a much simpler fashion.
Exercises

Rework the entire program to use no more than one print method in each block.
A truly elegant solution to this problem relies on statements that haven't been introduced yet, notably for. However there is a more elegant and space efficient solution that accomplishes everything we did above, does not use the + operator, and uses only if's and a single else. No else if's are needed. Can you find it?
Variables and Arithmetic Expressions

We'll begin this section by finding a more elegant way to handle multiple command line arguments of an undetermined number. Toward this end we introduce the concept of a loop. A loop is a section of code that is executed repeatedly until a stopping condition is met. A typical loop may look like:
while there's more data {
  Read a Line of Data
  Do Something with the Data
}
This isn't working code but it does give you an idea of a very typical loop. We have a test condition (Is there more data?) and something we want to do with if the condition is met. (Read a Line of Data and Do Something with the Data.)
There are many different kinds of loops in Java including while, for, and do while loops. They differ primarily in the stopping conditions used.

For loops typically iterate a fixed number of times and then exit. While loops iterate continuously until a particular condition is met. You usually do not know in advance how many times a while loop will loop.

In this case we want to write a loop that will print each of the command line arguments in succession, starting with the first one. We don't know in advance how many arguments there will be, but we can easily find this out before the loop starts using the args.length. Therefore we will write this with a for loop. Here's the code:

// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      int i;
    
      /* Now let's say hello */
      System.out.print("Hello ");
      for (i=0; i < args.length; i = i+1) {
        System.out.print(args[i]);
        System.out.print(" ");
      }
      System.out.println();
  }

}
We begin the code by declaring our variables. In this case we have exactly one variable, the integer i.
Then we begin the program by saying "Hello" just like before.

Next comes the for loop. The loop begins by initializing the counter variable i to be zero. This happens exactly once at the beginning of the loop. Programming tradition that dates back to Fortran insists that loop indices be named i, j, k, l, m and n in that order. This is purely a convention and not a feature of the Java language. However anyone who reads your code will expect you to follow this convention. If you choose to violate the convention, try to give your loop variables mnemonic names like counter or loop_index.

Next is the test condition. In this case we test that i is less than the number of arguments. When i becomes equal to the number of arguments, (args.length) we exit the loop and go to the first statement after the loop's closing brace. You might think that we should test for i being less than or equal to the number of arguments; but remember that we began counting at zero, not one.

Finally we have the increment step, i=i+1. This is executed at the end of each iteration of the loop. Without this we'd continue to loop forever since i would always be less than args.length. (unless, of course, args.length were less than or equal to zero. When would this happen?).

Sidebar: Why Algebra teachers hate Basic and aren't that fond of C

The statement i=i+1 drives algebra teachers up the wall. It's an invalid assertion. There isn't a number in the world for which the statement i=i+1 is true. In fact if you subtract i from both sides of that equation you get the patently false statement that 0 = 1. The trick here is that the symbol = does not imply equality. That is reserved for the double equals sign, ==. In almost all programming languages including Java a single equals sign is the assignment operator.
The notable exceptions are Pascal (and the Pascal derivatives Modula-2, Modula-3 and Oberon), Ada, and Eiffel where = does in fact mean equality and where := is the assignment operator. Math teachers are very fond of their equal sign and don't like to see it abused. This is one reason why Pascal is still the most popular language for teaching programming, especially in schools where the Computer Science department is composed mainly of math professors.

Needless to say math professors hate languages like Basic where, depending on context, = can mean either assignment or equality.

Exercises

What happens now if we don't give the Hello program any command line arguments? We aren't testing the number of command line arguments anymore so why isn't an ArrayIndexOutOfBoundsException thrown?
For math whizzes only: I lied. In certain interpretations of certain number systems the statement i = i + 1 does have a valid solution for i. What is it?
Classes and Objects: A First Look

Classes are the single most important feature of Java. Everything in Java is either a class, a part of a class, or describes how a class behaves. Although classes will be covered in great detail in section four, they are so fundamental to an understanding of Java programs that a brief introduction is going to be given here.
All the action in Java programs takes place inside class blocks, in this case the HelloWorld class. In Java almost everything of interest is either a class itself or belongs to a class. Methods are defined inside the classes they belong to. This may be a little confusing to C++ programmers who are used to defining all but the simplest methods outside the class block, but this approach is really more sensible. C++ takes the road it does primarily out of desire to be compatible with C, not out of good object-oriented design. Both syntactically and logically everything in Java happens inside a class.

Even basic data primitives like integers often need to be incorporated into classes before you can do many useful things with them. The class is the fundamental unit of Java programs, not source code files like in C. For instance consider the following Java program:

class HelloWorld {

  public static void main (String args[]) {

    System.out.println("Hello World");

  }

}

class GoodbyeWorld {

  public static void main (String args[]) {

    System.out.println("Goodbye Cruel World!");

  }

}
Save this code in a single file called hellogoodbye.java in your javahtml directory, and compile it with the command javac hellogoodbye.java. Then list the contents of the directory. You will see that the compiler has produced two separate class files, HelloWorld.class and GoodbyeWorld.class.
The second class is a completely independent program. Type java GoodbyeWorld and then type java HelloWorld. These programs run and execute independently of each other although they exist in the same source code file. Off the top of my head I can't think of why you might want two separate programs in the same file, but if you do the capability is there.

It's more likely that you'll want more than one class in the same file. In fact you'll see source code files with many classes and methods.

In fact there are a few statements that can, at least at first glance, appear outside a class. Import statements appear at the start of a file outside of any classes. However the compiler replaces them with the contents of the imported file which consists of, you guessed it, more classes.

Interfaces

Like we said, Java source is really just classes. Import statements are shorthand for many different classes; and comments aren't really there (as far as the compiler is concerned) in the first place. However there is one thing in Java source code that is neither a class nor a member of a class. That's an interface. We're not going to say much about interfaces yet since that's a subject for a more advanced chapter. However we will note that an interface defines methods that a class implements. In other words it declares what certain classes do. However an interface itself does nothing. All the action at least, happens inside classes.

FahrToCelsius

Java is not just used for the World Wide Web. The next program demonstrates a classic use of computers that goes back to the earliest punch card machines. It's reminiscent of some of the very first useful programs I ever wrote. These were designed to quickly calculate several dozen numbers to keep me from having to do them by hand in physics lab. It's also borrowed directly from Kernighan and Ritchie.
// Print a Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {
  
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;      // lower limit of temperature table
  upper = 300;  // upper limit of temperature table
  step  = 20;     // step size

  fahr = lower;
  while (fahr <= upper) {  // while loop begins here
    celsius = 5 * (fahr-32) / 9;
    System.out.print(fahr);
    System.out.print(" ");
    System.out.println(celsius);
    fahr = fahr + step;
  } // while loop ends here
} // main ends here

} //FahrToCelsius ends here 
This program calculates the Celsius equivalent of Fahrenheit temperatures between zero and three hundred degrees. The first two lines of the main method declare the variables we'll use. That is they specify the names and the types. For now we use only integers. In Java an int can have a value between -2,147,483,648 to 2,147,483,647. More types will be forthcoming.
Then we initialize the variables using statements like "lower = 0". This sets lower's initial value to 0. When used this way the equals sign is called the assignment operator.

After establishing the initial values for all our variables we go into the loop which does the main work of our program. At the beginning of each iteration of the loop (fahr <= upper) checks to see if the value of fahr is in fact less than or equal to the current value of upper. If it is then the computer executes the statements in the loop block (everything between "while loop begins here" and "while loop ends here".) Loops in Java are marked off by matching pairs of braces and may be nested.

celsius = 5 * (fahr-32) / 9; actually calculates the Celsius temperature given the fahrenheit temperature. The arithmetic operators here do exactly what you'd expect. * means multiplication. - is subtraction. / is division; and +, though not used in here, is addition. Precedence follows normal algebraic conventions, and can be rearranged through parentheses.

Java contains an almost complete set of arithmetic operators. Like C it is missing an exponentiation operator. For exponentiation you need to use the pow methods in the java.lang.Math package.

Printing output is very similar to what you've seen before. We use System.out.print(fahr) to print the fahrenheit value, then System.out.print(" ") to print a one-character string containing a space, and finally System.out.println(celsius); the Celsius value.

Finally we increment the value of fahr by step to move on to the next value in the table.

Floating Point Variables

You may have noticed something a little funny about the above output. The numbers aren't exactly correct. Zero degrees Fahrenheit is actually -17.778 degrees Celsius, not -18 degrees Celsius as this program reports. The problem is that we used only integers here, not decimal numbers. In computer-speak decimal numbers are called "floating point numbers."

Floating point numbers can represent a broader range of values than integers. For example you can write very large numbers like the speed of light (2.998E8 meters per second) and very small numbers like Plank's constant (6.63E-27 ) using the same number of digits. On the other hand you lose some precision that you probably didn't need for such large and small numbers anyway.

Some languages have a third kind of number called a fixed point number. This number has a set precision, for instance two decimal places, and is often useful in monetary calculations. Java has no fixed point data type.

Using floating point numbers is no harder than using integers. We can make our Fahrenheit to Celsius program more accurate merely by changing all our int variables into double variables.

// Print a more accurate Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {

    double fahr, celsius;
    double lower, upper, step;

    lower = 0.0;      // lower limit of temperature table
    upper = 300.0;  // upper limit of temperature table
    step  = 20.0;     // step size
 
    fahr = lower;
    while (fahr <= upper) {  // while loop begins here
      celsius = 5.0 * (fahr-32.0) / 9.0;
      System.out.print(fahr);
      System.out.print(" ");
      System.out.println(celsius);
      fahr = fahr + step;
    } // while loop ends here
  } // main ends here

} //FahrToCelsius ends here 
I've made one further change to the Fahrenheit to Celsius program. All the integer constants in the program like 5 and 9 have become 5.0 and 9.0 and so on. If a constant number includes a decimal point, then the compiler assumes it's a double precision floating point number. If it doesn't then the compiler assumes it's an integer. However when two numbers of different types such as integer and floating point are involved in a calculation on the right hand side of an equation, the compiler promotes the number of the weaker type to the stronger type before doing the calculation.
What makes one type of number stronger than another? It's the ability to represent a broader spectrum of numbers. Since a byte can only represent 256 numbers it's weaker than a short which can stand for 65,535 different numbers including all the numbers a byte can represent. Similarly an int is stronger than a short. Floating point numbers are stronger than any integer type and doubles are the strongest type of all.

Therefore we could have left all the small constants as integers and the program output would have been unchanged. However it is customary to put in decimal points to remind yourself and anyone else who may be unlucky enough to have to read your code, exactly what is going on.

This applies to calculations that take place on the right hand side of an equal sign. The left hand side of the equals sign is a different story. In fact it's so different that programmers have given the different sides of the equals sign special names. The left-hand side is called an lvalue while the right hand side is called an rvalue.

An rvalue is a calculated result and as specified above it takes on the strongest type of any number involved in the calculation. On the other hand the lvalue has a type that must be defined before it is used. That's what all those float fahr, celsius; statements are doing. Once the type of an lvalue is defined it never changes. Thus if we declare fahr to be an int, then on the left hand side of an equals sign fahr will always be an int, never a float or a double or a long.

If you've been following along you may notice a problem here. What if the type on the left doesn't match the type on the right? e.g. what happens with code like the following?

class FloatToInt  {

  public static void main (String args[]) {

    int myInteger;

    myInteger = 9.7;

  } // main ends here

} //FloatToInt ends here 
Two things can happen. If, as above, we're trying to move a number into a weaker type of variable, the compiler generates an error. On the other hand if we're trying to move a weaker type into a stronger type then the compiler converts it to the stronger type. For instance the following code is legal:
class IntToFloat  {

  public static void main (String args[]) {

    float myFloat;
    int   myInteger;

    myInteger = 9;
    myFloat = myInteger;
    System.out.println(myFloat);

  } // main ends here

} //IntToFloat ends here 
Exercises

Have the FahrToCelsius program print a heading above the table.
Write a similar program to convert Celsius to Fahrenheit.
The For Statement

Java isn't as redundant as perl, but there's still almost always more than one way to write any given program. The following program produces identical output to the Fahrenheit to Celsius program in the preceding section. The main difference is the for loop instead of a while loop.
// Print a Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {
  
    int fahr, celsius;
    int lower, upper, step;

    lower = 0;      // lower limit of temperature table
    upper = 300;  // upper limit of temperature table
    step  = 20;     // step size

    for (fahr=lower; fahr <= upper; fahr = fahr + step) {  
      celsius = 5 * (fahr-32) / 9;
      System.out.println(fahr + " " + celsius);
    } // for loop ends here

  } // main ends here

}
The only difference between this program and the previous one is that here we've used a for loop instead of a while loop. The for loop has identical syntax to C's for loops. i.e.

for (initialization; test; increment) The initialization, in this case setting the variable fahr equal to the lower limit, happens the first time the loop is entered and only the first time. Then the first time and every time after that when control reaches the top of the loop a test is made. In our example the test is whether the variable fahr is less than or equal to the upper limit. If it is we execute the code in the loop one more time. If not we begin executing the code that follows the loop. Finally at the end of each loop the increment step is made. In this case we increase fahr by step.
If that's unclear let's look at a simpler example:

//Count to ten

class CountToTen  {

  public static void main (String args[]) {
  
    int i;
    for (i=1; i <=10; i = i + 1) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}
This program prints out the numbers from one to ten. It begins by setting the variable i to 1. Then it checks to see if one is in fact less than or equal to ten. Since one is less than ten, the program prints it. Finally it adds one to i and starts over. i is now 2. The program checks to see if 2 is less than 10. It is! so the program prints "2" and adds one to i again. i is now three. Once again the code checks to see that 3 is less than or equal to 10. This is getting rather boring rather quickly. Fortunately computers don't get bored, and very soon computer has counted to the point where i is now ten. The computer prints "10" and adds one to ten. Now i is eleven. Eleven is not less than or equal to ten so the computer does not print it. Rather it moves to the next statement after the end of the for loop, System.out.println("All done!);. The computer prints "All Done!" and the program ends.
For loops do not always work this smoothly. For instance consider the following program:

//Count to ten??

class BuggyCountToTen  {

  public static void main (String args[]) {
  
    int i;
    for (i=1; i <=10; i = i - 1) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}
This program counts backwards. There's nothing fundamentally wrong with a program counting backwards, but we're testing for i being bigger than ten. Since i is never going to be bigger than ten in this program, the program never stops. (That's not completely true. If you have a very fast machine or you wait long enough somewhere below negative two billion i will suddenly become a very large positive number and the program will halt. This happens because of vagaries in computer arithmetic we'll discuss later. Nonetheless this is still almost certainly a bug. If you don't want to wait for that to happen just type Control-C to abort the program. This sort of behavior is referred to as an infinite loop and is a more common programming error than you might think.
Assignment, Increment and Decrement Operators

In reality almost nobody writes for loops like we did in the previous sections. They would almost certainly use the increment or decrement operators instead. There are two of these, ++ and -- and they work like this.
//Count to ten

class CountToTen  {

  public static void main (String args[]) {
    int i;
    for (i=1; i <=10; i++) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}
//Count to ten??

class BuggyCountToTen  {

  public static void main (String args[]) {
    int i;
    for (i=1; i <=10; i--) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

  }

}
When we write i++ we're using shorthand for i = i + 1. When we say i-- we're using shorthand for i = i - 1. Adding and subtracting one from a number are such common operations that these special increment and decrement operators have been added to the language. They also allow the compiler to be smarter about certain optimizations on some CPU architectures, but mainly they make code easier to write and read.
However what do you do when you want to increment not by one but by two? or three? or fifteen? We could of course write i = i + 15 but this happens frequently enough that there's another short hand for the general add and assign operation, +=. We would normally write this as i += 15. Thus if we wanted to count from 0 to 20 by two's we'd write:

class CountToTwentyByTwos  {

  public static void main (String args[]) {
    int i;
    for (i=0; i <=20; i += 2) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

 } //main ends here

}
As you might guess there is a corresponding -= operator. If we wanted to count down from twenty to zero by twos we could write:
class CountToZeroByTwos  {

  public static void main (String args[]) {
    int i;
    for (i=20; i >= 0; i -= 2) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

  }

}
You should note that we also had to change the initialization and test components of the for loop to count down instead of up.
There are also *= and /= operators that multiply and divide by their right hand sides before assigning. In practice you almost never see these because of the speed at which variables making use of them go to either zero or Inf. If you don't believe me consider the following cautionary tale.

Many centuries ago in India a very smart man is said to have invented the game of chess. This game greatly amused the king, and he became so enthralled with it that he offered to reward the inventor with anything he wished, up to half his kingdom and his daughter's hand in marriage.

Now the inventor of the game of chess was quite intelligent and not a little greedy. Not being satisfied with merely half the kingdom, he asked the king for the following gift:

"Mighty King," he said, "I am but a humble man and would not know what to do with half of your kingdom. Let us merely calculate my prize as follows. Put onto the first square of the chessboard a single grain of wheat. Then onto the second square of the chessboard two grains, and onto the third square of the chessboard twice two grains, and so on until we have covered the board with wheat."

Upon hearing this the king was greatly pleased for he felt he had gotten off rather cheaply. He rapidly agreed to the inventor's prize. He called for a bag of wheat to be brought to him, and when it arrived he began counting out wheat. However he soon used up the first bag and was not yet halfway across the board. He called for a second, and a third, and more and more, until finally he was forced to admit defeat and hand over his entire kingdom for lack of sufficient wheat with which to pay the inventor.

How much wheat did the king need? Let's try to calculate it. Although we won't use physical wheat, we will soon find ourselves in the same dire straits as the king. Remember that a chessboard has 64 squares.

class CountWheat  {

  public static void main (String args[]) {
  
    int i, j, k;

    j = 1;
    k = 0;

    for (i=1; i <= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
    } 
    System.out.println("All done!");

  }

}
We can improve our results slightly (but only slightly) by changing our ints to longs like so:
class CountWheat {

  public static void main (String args[]) {
  
    long i, j, k;

    j = 1;
    k = 0;

    for (i=1; i <= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
    } 
    System.out.println("All done!");

  }

}
A long is an integer type variable that can hold up to 9,223,372,036,854,775,807. However even that isn't enough to count how much wheat the king owed. Let's try using a double instead, the largest type of all.
class CountWheat {

  public static void main (String args[]) {
  
  int i;
  double j, k;
  
  j = 1.0;
  k = 0.0;
  
  for (i=1; i <= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
  } 
  System.out.println("All done!");

}

}
A double can hold a number as large as 1.79769313486231570e+308. That turns out to be large enough to count the king's debt which comes to 1.84467e+019 grains of wheat, give or take a few billion grains. That's a lot of wheat.
Exercises

Would a float be big enough to count how many grains of wheat the king owes?
Why isn't there a ** or a // operator?
Methods

All the programs we've written to date have been quite simple, well under fifty lines of code each. As programs grow in size it begins to make sense to break them into parts. Each part can perform a particular calculation and possibly return a value. This is especially useful when the calculation needs to be repeated at several different places in the program. It also helps to define a clearer picture of the flow of the program, much like an outline shows the flow of a book.
Each calculation part of a program is called a method. Methods are logically the same as C's functions, Pascal's procedures and functions, and Fortran's functions and subroutines.

The above programs have already used a number of methods although these were all methods provided by the system. When we wrote System.out.println("Hello World!"); in the first program we were using the System.out.println() method. (To be more precise we were using the println() method of the out member of the System class, but we'll talk more about that in Chapter 4.) The System.out.println() method actually requires quite a lot of code, but it is all stored for us in the System libraries. Thus rather than including that code every time we need to print, we just call the System.out.println() method.

You can write and call your own methods too. Let's look at a simple example. Java has no built-in factorial method so we'll write one. The following is a simple program that requests a number from the user and then calculates the factorial of that number.

We'll use two methods in the program, one that checks to see if the user has in fact entered a valid positive integer, and another that calculates the factorial. However we'll start by writing the main method of the program:

class Factorial {

  public static void main(String args[]) {

    int n;

    while ((n = getNextInteger()) >= 0)  {
      System.out.println(factorial(n));
    }

  } // main ends here

}
Among other things this code demonstrates that methods make it possible to design the flow of a program without getting bogged down in the details. We've simply named two methods, getNextInteger() and factorial() without worrying about their exact implementations. We can add the rest of the code in smaller, easier-to-understand pieces. Let's write the factorial method first.
long factorial (long n) {

  int i;
  long result=1;
  
  for (i=1; i <= n; i++) {
   result *= i;
  }
  
  return result;

} // factorial ends here
We could have included this code in our main method, but the algorithm is much easier to understand by breaking the code into smaller, more manageable pieces. It's also easier to test and debug. We can write a simple program that lets us test the factorial method before we worry ourselves with the much harder problem of accepting and validating user input. Here's the test program:
class FactorialTest {

  public static void main(String args[]) {

    int n;
    int i;
    long result;

    for (i=1; i <=10; i++)  {
      result = factorial(i);
      System.out.println(result);
    }

  } // main ends here
  
  
  static long factorial (int n) {

  int i;
  long result=1;
  
  for (i=1; i <= n; i++) {
   result *= i;
  }
  
  return result;

} // factorial ends here


}
C++ programmers should take note that both methods are defined inside the class definition. Once again we see that in Java everything belongs to a class.
Let's take a closer look at the syntax of a method:

 static long factorial (int n) {

  int i;
  long result=1;
  
  for (i=1; i <= n; i++) {
   result *= i;
  }
  
  return result;

}
Methods begin with a declaration. This can include three to five parts. First is an optional access specifier which can be public, private or protected. A public method can be called from pretty much anywhere. A private method can only be used within the class where it is defined. A protected method can be used anywhere within the package in which it is defined. Methods that aren't specifically declared public or private are protected by default.
Next we decide whether the method is or is not static. Static methods have only one instance per class rather than one instance per object. All objects of the same class share a single copy of a static method. By default methods are not static.

Next we specify the return type. This is the value that will be sent back to the calling method when all calculations inside the method are finished. If the return type is int, for example, we can use the method anywhere we use a constant integer. If the return type is void then no value will be returned.

Next is the name of the method.

Then there are parentheses. Inside the parentheses we give names and types to the arguments of the method. A method may have no arguments or it may have one or several. These arguments can be used inside the method just like local variables.

Finally the rest of the method is enclosed in braces to make it a single block. The part inside braces is just like the main methods we've been exploring till now. There are variable declarations, some code, and finally something new, a return statement. The return statement sends a value back to the calling method. The type of this value must match the declared type of the method.

In general any line that looks like Text(arg1, arg2) or text(arg1) or text() is a method call. The compiler is responsible for distinguishing between parentheses that mean method calls and parentheses that serve as grouping operators in mathematical expressions like (3 + 7) * 2. The compiler does a very good job of this and you may safely assume that anything that isn't clearly an arithmetical expression is a method call.

Methods break up a program into logically separate algorithms and calculations. In still larger programs it's necessary to break up the data as well. The data can be separated into different classes and the methods attached to the classes they operate on. This is the heart of object oriented programming and the subject of Chapter 4 below.

Recursive Methods

Java supports recursive methods, i.e. even if you're already inside methodA() you can call methodA(). The easiest way I can think of to explain recursion is to look at a simple acronym, GNU. The GNU project, among other things, is trying to produce free versions of the Unix operating system and many Unix tools, such as lex, yacc, and cc. One minor problem with this effort is that the name Unix is trademarked so the GNU project can't use it. Hence, instead of Unix, we have GNU, where GNU stands for "Gnu's Not Unix." The definition of GNU refers to itself; that is, it's recursive. So what is GNU? One level deeper it's "(Gnu's Not Unix)'s Not Unix." One level deeper still, it becomes "((Gnu's Not Unix)'s Not Unix)'s Not Unix." And so on, ad infinitum. It's like standing between a pair of mirrors. The images just fade off into the distance with no clear end in sight. In computer programming recursion is achieved by allowing a method to call itself.

You probably already see one problem with recursion. Where does it all end? In fact when you write recursive methods you have to be careful to include stopping conditions. Although Java doesn't put any particular limits on the depth to which you can expand a recursion, it is very possible to have a run-away recursion eat up all the memory in your computer.

Let's look at an example. n! (pronounced "En-factorial") is defined as n times n-1 times n-2 times n-3 ... times 2 times 1 where n is a positive integer. 0! is defined as 1. As you see n! = n time (n-1)!. This lends itself to recursive calculation, as in the following method:

public static long factorial (int n) {

  if (n == 0) {
    return 1;
  }
  else {
    return n*factorial(n-1);
  }

}
Something to think about: What happens if a negative integer is passed into the factorial method? For example suppose you ask for factorial(-1). Then you get the following chain of calls: -1 * -2 * -3 * -4 * .... If you're lucky your program may unexpectedly pop into the positive numbers and count down to zero. If you're not, your program will crash with a StackOutOfMemoryError. Stopping conditions are very important. In this case you should check to see if you've been passed a negative integer; and, if you have been, return infinity. (The factorial is a special case of the gamma function for non-negative integers. Although the factorial function is only defined for non-negative integers, the gamma function is defined for all real numbers. It is possible to show that the gamma function is infinite for negative integers.) Java doesn't support infinite values for longs, though, so return the warning value -1 instead. (Java does support infinite values for floats and doubles.) Here's a better recursive factorial method:
public static long factorial (int n) {

  if (n < 0) {
    return -1;
  } 
  else if (n == 0) {
    return 1;
  }
  else {
    return n*factorial(n-1);
  }

}
It can be proven mathematically that all recursive algorithms have non-recursive counterparts. For instance the factorial method could have been written non-recursively like this:
public static long factorial (int n) {

  long result = 1;
  
  for (int i = 1; i <= n; i++) {
    result *= i;
  }
  
  return result;

}
The non-recursive equivalent in this problem is straight-forward, but sometimes the non-recursive counterpart to a recursive algorithm isn't at all obvious. To see that one always exists, note that at the machine level of the computer, there's no such thing as recursion and that everything consists of values on a stack. Therefore even if you can't find a simpler way to rewrite the algorithm without recursion, you can always use your own stack instead of the Java stack.
Here's an example of a recursive program for which I have not been able to find a simple, non-recursive equivalent method. The goal is to find all possible RAM configurations for a PC, given the size of the memory chips it will accept and the number of slots it has available. We are not concerned with how the RAM is arranged inside the PC, only with the total quantity of installed RAM. For some computers this can easily be calculated by hand. For instance Apple's PowerBook 5300 series comes with 8 megabytes of RAM soldered onto the logic board and one empty slot that can hold chips of 8, 16, 32 or 56 MB capacity. Therefore the possible Ram configurations are 8, 16, 24, 40 and 64 MB. However as the number of available slots and the number of available chip sizes increases this becomes a much more difficult problem. The following is a recursive program to calculate and print all possible RAM configurations:


import java.util.Hashtable;
import java.util.Enumeration;

public class RamConfig {

   static int[] sizes = {0, 8, 16, 32, 64};
   static Hashtable configs = new Hashtable(64);
   static int slots[] = new int[4];

   public static void main (String args[]) {

     System.out.println("Available DIMM sizes are: ");
     for (int i=0; i < sizes.length; i++) System.out.println(sizes[i]);

     fillSlots(slots.length - 1);
     System.out.println("Ram configs are: ");

     for (Enumeration e = configs.elements(); e.hasMoreElements(); ) {
       System.out.println(e.nextElement());    
     }
     
   }
   
  
  private static void fillSlots(int n) {
  
    int total;
     
    for (int i=0; i < sizes.length; i++) {
       slots[n] = sizes[i];
       if (n == 0) {
          total = 0;
          for (int j = 0; j < slots.length; j++) {
            total += slots[j];
          }
          configs.put(Integer.toString(total), new Integer(total));
       }
       else {
         fillSlots(n - 1);
       }
    }      
  
  }
  
}
Recursive methods are also useful for benchmarking. In particular, deep recursion tests the speed with which a language can make method calls. This is important because modern applications have a tendency to spend much of their time calling various API functions. PCWeek uses a benchmark they invented called Tak which performs 63,609 recursive method calls per pass. The algorithm is simple: If y is greater than or equal to x, Tak(x, y, z) is z. This is the nonrecursive stopping condition. Otherwise, if y is less than x, Tak(x, y, z) is Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y)). The Tak benchmark calculates Tak(18, 12, 6) between 100 and 10000 times and reports the number of passes per second. For more information about the Tak benchmark see Peter Coffee's article, "Tak test stands the test of time" on p. 91 of the 9-30-1996 PCWeek. (The article may be on PCWeek's web site somewhere, but regrettably that site, while it looks pretty, is lacking some basic navigation aids. I was unable to locate the article, either directly or through their search engine. If anyone finds the URL let me know.)
Below is my variation of this benchmark. There are overloaded integer and floating point versions of the Tak method. Integer is used by default. If the -f flag is given on the command line, the floating point method is used. The number of passes to make may also be entered from the command line. If it is not, 1000 passes are made. The Java Date class is used to time that part of the test where the benchmarking is done.

import java.util.Date;


public class Tak {

  public static void main(String[] args) {
   
   boolean useFloat = false;
   int numpasses;
   
   for (int i = 0; i < args.length; i++) {
     if (args[i].startsWith("-f")) useFloat = true;
   }
   try {
     numpasses = Integer.parseInt(args[args.length-1]);
   }
   catch (Exception e) {
     numpasses = 1000;
   }
   
   Date d1, d2;
   if (useFloat) {
     d1 = new Date();
     for (int i = 0; i < numpasses; i++) {
        Tak(18.0f, 12.0f, 6.0f);
     }
     d2 = new Date();
   }
   else {
     d1 = new Date();
     for (int i = 0; i < numpasses; i++) {
        Tak(18, 12, 6);
     }
     d2 = new Date();
   
   }
   long TimeRequired = d2.getTime() - d1.getTime();
   double numseconds = TimeRequired/1000.0;
   
   System.out.println("Completed " + numpasses + " passes in " 
    + numseconds + " seconds" );
   System.out.println(numpasses/numseconds + " calls per second");
  
  }

  public static int Tak(int x, int y, int z) {
    if (y >= x) return z;
    else return Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y));   
  
  }

  public static float Tak(float x, float y, float z) {
    if (y >= x) return z;
    else return Tak(Tak(x-1.0f, y, z), Tak(y-1.0f, z, x), Tak(z-1.0f, x, y));   
  
  }

}
If you'd like to try this out right away, you can use the applet interface to the Tak benchmark at http://metalab.unc.edu/javafaq/newsletter/TakApplet.html.
My Powerbook 5300 achieved speeds between 3.5 and 5 passes per second on this test. Sun's Mac VM was about 10% faster on this test than Natural Intelligence's. The heavily loaded Sparcstation at metalab.unc.edu (load average 4+) achieved a little more than 3 passes per second. Given the various external factors affecting machine performance, these are hardly scientific measurements. I'd be curious to hear what your results are.

Exercises

Find the non-recursive equivalent to the Ram Config algorithm.
Arrays

In non-trivial computing problems you often need to store lists of items. Often these items can be specified sequentially and referred to by their position in the list. Sometimes this ordering is natural as in a list of the first ten people to arrive at a sale. The first person would be item one in the list, the second person to arrive would be item two, and so on. Other times the ordering doesn't really mean anything such as in the ram configuration problem of the previous chapter where having a 4 MB SIMM in slot A and an 8 MB SIMM in slot B was effectively the same as an 8 MB SIMM in slot A and a 4 MB SIMM in slot B. However it's still convenient to be able to assign each item a unique number and enumerate all the items in a list by counting out the numbers.
There are many ways to store lists of items including linked lists, sets, hashtables, binary trees and arrays. Which one you choose depends on the requirements of your application and the nature of your data. Java provides classes for many of these ways to store data and we'll explore them in detail in the chapter on the Java Class Library.

Arrays are probably the oldest and still the most generally effective means of storing groups of variables. An array is a group of variables that share the same name and are ordered sequentially from zero to one less than the number of variables in the array. The number of variables that can be stored in an array is called the array's dimension. Each variable in the array is called an element of the array.

An array can be visualized as a column of data like so:

I[0]
I[1]
I[2]
I[3]
I[4]
4
2
76
-90
6
In this case we're showing an integer array named I with five elements; i.e. the type of the array is int and the array has dimension 5.

Creating Arrays

There are three steps to creating an array, declaring it, allocating it and initializing it.

Declaring Arrays

Like other variables in Java, an array must have a specific type like byte, int, String or double. Only variables of the appropriate type can be stored in an array. You cannot have an array that will store both ints and Strings, for instance.
Like all other variables in Java an array must be declared. When you declare an array variable you suffix the type with [] to indicate that this variable is an array. Here are some examples:

int[] k;
float[] yt;
String[] names;
In other words you declare an array like you'd declare any other variable except you append brackets to the end of the variable type.
Allocating Arrays

Declaring an array merely says what it is. It does not create the array. To actually create the array (or any other object) use the new operator. When we create an array we need to tell the compiler how many elements will be stored in it. Here's how we'd create the variables declared above:
k = new int[3];
yt = new float[7];
names = new String[50];
The numbers in the brackets specify the dimension of the array; i.e. how many slots it has to hold values. With the dimensions above k can hold three ints, yt can hold seven floats and names can hold fifty Strings. Therefore this step is sometimes called dimensioning the array. More commonly this is called allocating the array since this step actually sets aside the memory in RAM that the array requires.
This is also our first look at the new operator. new is a reserved word in java that is used to allocate not just an array, but also all kinds of objects. Java arrays are full-fledged objects with all that implies. For now the main thing it implies is that we have to allocate them with new.

Initializing Arrays

Individual elements of the array are referenced by the array name and by an integer which represents their position in the array. The numbers we use to identify them are called subscripts or indexes into the array. Subscripts are consecutive integers beginning with 0. Thus the array k above has elements k[0], k[1], and k[2]. Since we started counting at zero there is no k[3], and trying to access it will generate an ArrayIndexOutOfBoundsException.
You can use array elements wherever you'd use a similarly typed variable that wasn't part of an array.

Here's how we'd store values in the arrays we've been working with:

k[0] = 2;
k[1] = 5;
k[2] = -2;
yt[6] = 7.5f;
names[4] = "Fred";
This step is called initializing the array or, more precisely, initializing the elements of the array. Sometimes the phrase "initializing the array" would be reserved for when we initialize all the elements of the array.
For even medium sized arrays, it's unwieldy to specify each element individually. It is often helpful to use for loops to initialize the array. For instance here is a loop that fills an array with the squares of the numbers from 0 to 100.

float[] squares = new float[101];

for (int i=0; i <= 100; i++) {
  squares[i] = i*i;
}
Two things you should note about this code fragment:
Watch the fenceposts! Since array subscripts begin at zero we need 101 elements if we want to include the square of 100.
Although i is an int it becomes a float when it is stored in squares, since we've declared squares to be an array of floats.
One way to avoid fencepost errors is to use the array's built-in length member. This tells you the number of components in the array. In the example above, squares.length equals 101. Thus the loop could have been written like this:

float[] squares = new float[101];

for (int i=0, i < squares.length; i++) {
  squares[i] = i*i;
}
Note that the <= changed to a < to make this work.

Shortcuts

It may seem to be a lot of work to set up arrays, particularly if you're used to a more array friendly language like Fortran. Fortunately Java has several shorthands for declaring, dimensioning and strong values in arrays.

We can declare and allocate an array at the same time like this:

int[] k = new int[3];
float[] yt = new float[7];
String[] names = new String[50];
We can even declare, allocate, and initialize an array at the same time providing a list of the initial values inside brackets like so:

int[] k = {1, 2, 3};
float[] yt = {0.0f, 1.2f, 3.4f, -9.87f, 65.4f, 0.0f, 567.9f};
Counting Digits

We've already seen one example of an array. Main methods in an application store the command line arguments in an array of strings called args.

As our second example let's consider a class that counts the occurrences of the digits 0-9 in decimal expansion of the number pi, for example. This is an issue of some interest both to pure number theorists and to theologians. See, for example, Carl Sagan's Contact and John Updike's Roger's Version. More realistically we might wish to test the randomness of a random number generator. If a random number generator is truly random, all digits should occur with equal frequency over a sufficiently long period of time.

We will do this by creating an array of ten longs called ndigit. The zeroth element of ndigit will track the number of zeroes in the input stream; the first element of ndigit will track the numbers of 1's and so on. We'll test Java's random number generator and see if it produces apparently random numbers.

import java.util.*;

class RandomTest {

  public static void main (String args[]) {
  
    int[] ndigits = new int[10];
    double x;
    int n;
    
    Random myRandom = new Random();
  
    // Initialize the array 
    for (int i = 0; i < 10; i++) {
      ndigits[i] = 0;
    }

    // Test the random number generator a whole lot
    for (long i=0; i < 100000; i++) {
      // generate a new random number between 0 and 9
      x = myRandom.nextDouble() * 10.0;
      n = (int) x;
      //count the digits in the random number
      ndigits[n]++;
    }
    
    // Print the results
    for (int i = 0; i <= 9; i++) {
      System.out.println(i+": " + ndigits[i]);
    }
  }
  
}

We've got three for loops in this code, one to initialize the array, one to perform the desired calculation, and a final one to print out the results. This is quite common in code that uses arrays.

Two Dimensional Arrays

The most common kind of multidimensional array is a two-dimensional array. If you think of a one-dimensional array as a column of values you can think of a two-dimensional array as a table of values like so:

c0
c1
c2
c3
r0
0
1
2
3
r1
1
2
3
4
r2
2
3
4
5
r3
3
4
5
6
r4
4
5
6
7
Here we have an array with five rows and four columns. It has twenty total elements. However we say it has dimension five by four, not dimension twenty. This array is not the same as a four by five array like this one:

c0
c1
c2
c3
c4
r0
0
1
2
3
4
r1
1
2
3
4
5
r2
2
3
4
5
6
r3
3
4
5
6
7
We need to use two numbers to identify a position in a two-dimensional array. These are the element's row and column positions. For instance if the above array is called J then J[0][0] is 0, J[0][1] is 1, J[0][2] is 2, J[0][3] is 3, J[1][0] is 1, and so on.

Here's how the elements in a four by five array called M are referred to:

M[0][0]
M[0][1]
M[0][2]
M[0][3]
M[0][4]
M[1][0]
M[1][1]
M[1][2]
M[1][3]
M[1][4]
M[2][0]
M[2][1]
M[2][2]
M[2][3]
M[2][4]
M[3][0]
M[3][1]
M[3][2]
M[3][3]
M[3][4]
Declaring, Allocating and Initializing Two Dimensional Arrays

Two dimensional arrays are declared, allocated and initialized much like one dimensional arrays. However we have to specify two dimensions rather than one, and we typically use two nested for loops to fill the array.
The array examples above are filled with the sum of their row and column indices. Here's some code that would create and fill such an array:

class FillArray {

  public static void main (String args[]) {
  
    int[][] M;
    M = new int[4][5];
  
    for (int row=0; row < 4; row++) {
      for (int col=0; col < 5; col++) {
        M[row][col] = row+col;
      }
    }
    
  }
  
}
Of course the algorithm you would use to fill the array depends completely on the use to which the array is to be put. Here is a program which calculates the identity matrix for a given dimension. The identity matrix of dimension N is a square matrix which contains ones along the diagonal and zeros in all other positions.
class IDMatrix {

  public static void main (String args[]) {
  
    double[][] ID;
    ID = new double[4][4];
  
    for (int row=0; row < 4; row++) {
      for (int col=0; col < 4; col++) {
        if (row != col) {
          ID[row][col]=0.0;
        }
        else {
          ID[row][col] = 1.0;
        }
      }
    }
    
  }
  
}
In two-dimensional arrays ArrayIndexOutOfBounds errors occur whenever you exceed the maximum column index or row index. Unlike two-dimensional C arrays, two-dimensional Java arrays are not just one-dimensional arrays indexed in a funny way.
Exercises

Write a program to generate the HTML for the above tables.
Multidimensional Arrays

You don't have to stop with two dimensional arrays. Java lets you have arrays of three, four or more dimensions. However chances are pretty good that if you need more than three dimensions in an array, you're probably using the wrong data structure. Even three dimensional arrays are exceptionally rare outside of scientific and engineering applications.
The syntax for three dimensional arrays is a direct extension of that for two-dimensional arrays. Here's a program that declares, allocates and initializes a three-dimensional array:

class Fill3DArray {

  public static void main (String args[]) {
  
    int[][][] M;
    M = new int[4][5][3];
  
    for (int row=0; row < 4; row++) {
      for (int col=0; col < 5; col++) {
        for (int ver=0; ver < 3; ver++) {
          M[row][col][ver] = row+col+ver;
        }
      }
    }
    
  }
  
}
We need three nested for loops here to handle the extra dimension.
The syntax for still higher dimensions is similar. Just add another pair pf brackets and another dimension.

Unbalanced Arrays

Like C Java does not have true multidimensional arrays. Java fakes multidimensional arrays using arrays of arrays. This means that it is possible to have unbalanced arrays. An unbalanced array is a multidimensional array where the dimension isn't the same for all rows. IN most applications this is a horrible idea and should be avoided.

Searching

One common task is searching an array for a specified value. Sometimes the value may be known in advance. Other times you may want to know the largest or smallest element.

Unless you have some special knowledge of the contents of the array (for instance, that it is sorted) the quickest algorithm for searching an array is straight-forward linear search. Use a for loop to look at every element of the array until you find the element you want. Here's a simple method that prints the largest and smallest elements of an array:

   static void printLargestAndSmallestElements (int[] n) {
  
    int max = n[0];
    int min = n[0];
    
    for (int i=1; i < n.length; i++) {
      if (max < n[i]) {
        max = n[i];
      }
      if (min > n[i]) {
        min = n[i];
      }
    }
    
    System.out.println("Maximum: " + max);
    System.out.println("Minimum: " + min);
    
    return;
  
  }
  
If you're going to search an array many times, you may want to sort the array, before searching it. We'll discuss sorting algorithms in the next section.

Sorting

All sorting algorithms rely on two fundamental operations, comparison and swapping. Comparison is straight-forward. Swapping is a little more complex. Consider the following problem. We want to swap the value of a and b. Most people propose something like this as the solution:

class Swap1 {

  public static void main(String args[]) {
  
   int a = 1;
   int b = 2;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);
   
   // swap a and b
   
   a = b;
   b = a;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);   
  
  }

}
This produces the following output:

a = 1
b = 2
a = 2
b = 2
That isn't what you expected! The problem is that we lost track of the value 1 when we put the value of b into a. To correct this we need to introduce a third variable, temp, to hold the original value of a.
class Swap2 {

  public static void main(String args[]) {
  
   int a = 1;
   int b = 2;
   int temp;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);
   
   // swap a and b
   
   temp = a;
   a = b;
   b = temp;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);   
  
  }

}
This code produces the output we expect:

a = 1
b = 2
a = 2
b = 1
Bubble Sort

Now that we've learned how to properly swap the values of two variables, let's proceed to sorting. There are many different sorting algorithms. One of the simplest and the most popular algorithms is referred to as bubble sort. The idea of bubble sort is to start at the top of the array. We compare each element to the next element. If its greater than that element then we swap the two. We pass through the array as many times as necessary to sort it. The smallest value bubbles up to the top of the array while the largest value sinks to the bottom. (You could equally well call it a sink sort, but then nobody would know what you were talking about.) Here's the code:
import java.util.*;

class BubbleSort {

  public static void main(String args[]) {
  
   int[] n;
   n = new int[10];
   Random myRand = new Random();
   
   // initialize the array
   for (int i = 0; i < 10; i++) {
     n[i] = myRand.nextInt();
   }
   
   // print the array's initial order
   System.out.println("Before sorting:"); 
   for (int i = 0; i < 10; i++) {
     System.out.println("n["+i+"] = " + n[i]);
   }
   
   boolean sorted = false;
   // sort the array
   while (!sorted) {
     sorted = true;
     for (int i=0; i < 9; i++) {
       if (n[i] > n[i+1]) {
         int temp = n[i];
         n[i] = n[i+1];
         n[i+1] = temp;
         sorted = false;
       }   
     }
   }

  // print the sorted array
  System.out.println();
  System.out.println("After sorting:");  
   for (int i = 0; i < 10; i++) {
     System.out.println("n["+i+"] = " + n[i]);
   }

  
  }

}
In this case we have sorted the array in ascending order, smallest element first. It would be easy to change this to sort in descending order.
Catching Exceptions

Do you remember this code?
// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(args[0]);
  }

}
Do you remember what happened when you ran the program without giving it any command line arguments? The runtime system generated an exception
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException at Hello.main(C:\javahtml\Hello.java:7)

What happened was that since we didn't give Hello any command line arguments there wasn't anything in args[0]. Therefore Java kicked back this not too friendly error message about an "ArrayIndexOutOfBoundsException."

Previously we fixed this problem by testing the length of the array before we tried to access its first element. This worked well in this simple case, but this is far from the only such potential problem. If you were to check for every possible error condition in each line of code, you would find your code becoming bloated with more error checking than actual code. Moreover you then have to start checking for errors in the error conditions. In older languages like C, Basic and Fortran you sooner or later you find yourself resorting to goto or longjmp or other such ingredients in the recipe for illegible Spaghetti Code

The goal of exception handling is to be able to define the regular flow of the program in part of the code without worrying about all the special cases. Then, in a separate block of code, you cover the exceptional cases. This produces more legible code since you don't need to interrupt the flow of the algorithm to check and respond to every possible strange condition. The runtime environment is responsible for moving from the regular program flow to the exception handlers when an exceptional condition arises.

In practice what you do is write blocks of code that may generate exceptions inside try-catch blocks. You try the statements that generate the exceptions. Within your try block you are free to act as if nothing has or can go wrong. Then, within one or more catch blocks, you write the program logic that deals with all the special cases.

Here's an example of exception handling in Java using the Hello World program above:

// This is the Hello program in Java
class ExceptionalHello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      try {
        System.out.println("Hello " + args[0]);
      }
      catch (Exception e) {
        System.out.println("Hello whoever you are");      
      }
  }

}
Some exceptions need to be caught and dealt with while others are generally considered to be so horrific that the runtime system, just gives up. The compiler will complain if you write code that doesn't watch out for the not-too-dangerous exceptions, but you'll need to watch out for the really dangerous ones (like ArrayIndexOutOfBoundsExceptions) yourself.
Sometimes catching an exception can feel like a little yippy dog that finally catches a car. Now that it's got hold of the bumper between its teeth, what is it going to do with it? Many times there may not be much you can do. Bad exceptions stop the program by default. This is at least preferable to unhandled exceptions in most programming languages where the entire system can come crashing down around your feet with a core dump or worse. Sometimes you may want to this too. In that case you can call the System.exit(int) method to halt your running program.

Other times you may just break out of a loop you were in and continue with the rest of your code. This is most common when an exception isn't really unexpected or when it doesn't badly affect your program logic.

You may or may not print an error message. If you write an exception handler and you don't expect it to be called, then by all means put a

System.out.println("Error: " + e);

in your exception handler. That way if something does go wrong (and something always does) you'll at least know where it went wrong. However don't put an error message in exception handlers you expect to be exercised in the course of normal program flow. Remember, they're exceptions, not errors.

In the next section we'll see lots of examples of code that can possibly generate exceptions which must be caught. We'll talk more about exceptions in a later chapter, but this is the bare bones you need to know to respond to the exceptions generated by the java.io classes we'll be discussing in the next section.

File I/O and Streams

Sometimes you write data to a file instead of the computer screen. Under Unix and DOS you can sometimes do this using the redirection operators < and >. However sometimes you need a more fine-grained approach that writes only certain data to a file while still putting other data on the screen. Or you may need access to multiple files simultaneously. Or maybe you want to query the user for input rather than accepting it all on the command line. Or maybe you want to read data out of a file that's in a particular format. In Java all these methods take place as streams.
Streams are a big topic in Java and later we'll devote an entire chapter to them. For now we want to cover just the very basics that let you write files, read files and communicate with the user. In fact the System.out.println() statement we've been using all along is an implementation of Streams.

Interactively communicating with the user

We'll begin by writing a very simple program that asks the user for their name and then prints a personalized greeting.

import java.io.*;

class PersonalHello {

  public static void main (String args[])
    {
    
      byte name[] = new byte[100];
      int bytesRead = 0;

      System.out.println("What is your name?");
      try {
        bytesRead = System.in.read(name);
        System.out.print("Hello ");
        System.out.write(name, 0, bytesRead);
      }
      catch (IOException ex) {
        System.out.print("I'm Sorry.  I didn't catch your name.");
      }
      
    }
    
}
In code that does any significant input or output you'll want to begin by importing all the various java.io classes. import.java.io.*; does this and is as ubiquitous in Java applications as #include <stdio.h> is in C programs.

Most of the reading and writing you do in Java will be done with bytes. (As you'll see later there are also ways to read text files directly into Strings.) Here we've started with an array of bytes that will hold the user's name.

First we print a query requesting the user's name. Then we read the user's name using the System.in.read() method. This method takes a byte array as an argument, and places whatever the user types in that byte array. Then, like before, we print "Hello." Finally we print the user's name.

The program doesn't actually see what the user types until he or she types a carriage return. This gives the user the chance to backspace over and delete any mistakes. Once the return key is pressed, everything in the line is placed in the array.

What happens if the user types more than 100 characters of text before hitting a carriage return? In many programming languages this would lead to a rather nasty program crash. It's also the sort of bug that often gets out the door in a shipping product since programmers often fail to test their programs against extreme inputs. However Java has been programmed a little more safely. System.in.read() won't read past the end of the array even though we didn't explicitly check to make sure the input was sufficiently small. My guess is that the System.in.read() method internally checks the length of the array it's been passed using the name.length property.

Reading Numbers

Often strings aren't enough. A lot of times you'll want to ask the user for a number as input. All user input comes in as strings so we need to convert the string into a number.

Next we promised to write a getNextInteger() method that will accept an integer from the user. Here it is:

  static int getNextInteger() {
  
    String line;
  
    DataInputStream in = new DataInputStream(System.in);
    try {
      line = in.readLine();
      int i = Integer.valueOf(line).intValue();
      return i;
    }
    catch (Exception e) {
      return -1;
    }
       
  } // getNextInteger ends here
Reading Formatted Data

It's often the case that you want to read not just one number but multiple numbers. Sometimes you may need to read text and numbers on the same line. For this purpose Java provides the StreamTokenizer class.

Writing a text file

Sometimes you want to save your output for posterity rather merely scrolling it across a screen. To do this we'll need to learn how to write data to a file. rather than create a completely new program we'll modify the Fahrenheit to Celsius conversion program to output to a file:

// Write the Fahrenheit to Celsius table in a file

import java.io.*;

class FahrToCelsius  {

  public static void main (String args[]) {

    double fahr, celsius;
    double lower, upper, step;

    lower = 0.0;    // lower limit of temperature table
    upper = 300.0;  // upper limit of temperature table
    step  = 20.0;   // step size

    fahr = lower;
  
    try {

      FileOutputStream fout =  new FileOutputStream("test.out");

      // now to the FileOutputStream into a PrintStream
      PrintStream myOutput = new PrintStream(fout);
  
      while (fahr <= upper) {  // while loop begins here
        celsius = 5.0 * (fahr-32.0) / 9.0;
        myOutput.println(fahr + " " + celsius);
        fahr = fahr + step;
      } // while loop ends here
  
    }  // try ends here
    catch (IOException e) {
      System.out.println("Error: " + e);
      System.exit(1);
    }
  
  } // main ends here

}
There are only three things necessary to write formatted output to a file rather than to the standard output:
Open a FileOutputStream using a line like
FileOutputStream fout =  new FileOutputStream("test.out");
This line initializes the FileOutputStream with the name of the file you want to write into.
Convert the FileOutputStream into a PrintStream using a statement like
PrintStream myOutput = new PrintStream(fout);
The PrintStream is passed the FileOutputStream from step 1.
Instead of using System.out.println() use myOutput.println(). System.out and myOutput are just different instances of the PrintStream class. To print to a different PrintStream we keep the syntax the same but change the name of the PrintStream.
Reading a text file

Now that we know how to write a text file, let's try reading one. The following code implements the Unix cat utility in Java. That is it accepts a series of file names on the command line and then prints those filenames to the standard output in the order they were listed.
// Imitate the Unix cat utility

import java.io.*;

class cat  {

  public static void main (String args[]) {
  
  String thisLine;

  //Loop across the arguments
  for (int i=0; i < args.length; i++) {
 
  //Open the file for reading
  try {
    FileInputStream fin =  new FileInputStream(args[i]);

    // now turn the FileInputStream into a DataInputStream
    try {
      DataInputStream myInput = new DataInputStream(fin);
  
      try {
        while ((thisLine = myInput.readLine()) != null) {  // while loop begins here
          System.out.println(thisLine);
        } // while loop ends here
      }
      catch (Exception e) {
       System.out.println("Error: " + e);
      }
    } // end try
    catch (Exception e) {
      System.out.println("Error: " + e);
    }
  
   } // end try
   catch (Exception e) {
    System.out.println("failed to open file " + args[i]);
    System.out.println("Error: " + e);
  }
  } // for end here
  
  } // main ends here

}
Summing Up

If you've gotten this far, you're capable of doing a surprising amount of real work in Java. You may not think so since we haven't yet talked about a lot of the modern features of Java like most of its object orientation, many of the details of working with applets, or threads. However it's important to realize what you do have. Right now the Java you know is able to handle any problem that past generations have handled with Basic and Fortran 77.
FahrToCelsius is a very basic application that could be written in almost any programming language from the most ancient machine code to the most advanced LISP machine. Nonetheless it is important to notice that Java solves this problem just as easily as would a language more commonly associated with numeric and scientific programming such as Fortran or C. In fact this code was translated almost verbatim from Kernighan and Ritchie. Only a few minor semantic changes were required to produce a valid, efficient Java program. Although Java has many, many features that make it suitable for complex object-oriented applications, it is also fully suitable for classic numerical programs, something that is not true of competitors like SmallTalk or LISP.

In fact Java can outperform even Fortran and C in numerical applications when precision, reliability and portability are more important than speed. Java's true arrays with bounds checking and its well-defined IEEE 754 floating point data types are especially useful in this regard.

Since there is as of yet no native architecture compiler for Java, it's too early to throw away your Fortran manuals. CPU intensive applications will still be coded in Fortran. The Java language itself (as opposed to its implementation) is also lacking in a couple of important respects for numeric computation. The lack of an exponentiation operator like Fortran's ** and the lack of a complex data type are both troublesome to longtime Fortran programmers. However neither is insurmountable.

Would anyone care to write a Fortran to Java translator?

In the next chapter we'll move beyond the 1970's to discuss more modern features of Java including Objects, Applets, Event Driven Programming and threads.

Part 3: Applets

The last chapter was rooted solidly in the 1970's. It used techniques often referred to as "structured" or "procedural programming" which were popular then. (We skipped right over the most popular innovation of the 60's and the Basic programmer, spaghetti code). Certain programmers are sometimes said to "Write Fortran in any language," and that's more or less what we did. You now have the knowledge to accomplish with Java anything that can be done within the bounds of ANSI-standard Fortran 77.
In this chapter we're going to move into the 1980's. In particular we're going to work with event driven programming. This style of programming should be very familiar to Macintosh and Windows programmers. In those environments program logic doesn't flow from the top to the bottom of the program as it does in most procedural code. Rather the operating system collects events and the program responds to them. These events may be mouse clicks, keypresses, network data arriving on the Ethernet port, or any of about two dozen other possibilities. The operating system looks at each event, determines what program it was intended for, and places the event in the appropriate program's event queue.

Every application program has an event loop. This is just a while loop which loops continuously. On every pass through the loop the application retrieves the next event from its event queue and responds accordingly.

Java applets behave similarly. However the runtime environment (i.e. the browser) takes care of the event loop for the applet so there's no need to write one explicitly. Rather you need to have methods in your applet subclass that respond to each kind of event you want to process.

This is all fairly abstract until you see some concrete examples. Let's begin with a simple one.

Hello World: The Applet

The reason people are excited about Java as more than just another OOP language is because it allows them to write interactive applets on the web. Hello World isn't a very interactive program, but let's look at a webbed version.
import java.applet.Applet;    
import java.awt.Graphics; 
              
public class HelloWorldApplet extends Applet {

  public void paint(Graphics g) {
    g.drawString("Hello world!", 50, 25);
  }
  
}
This applet version of HelloWorld is a little more complicated than the HelloWorld application of the previous chapter, and it will take a little more effort to run it as well.
First type in the source code and save it into file called HelloWorldApplet.java in the javahtml/classes directory. Compile this file by typing javac HelloWorldApplet.java at the command line prompt.

If all is well a file called HelloWorldApplet.class will be created. This file must be in your classes directory.

Now you need to create an HTML file that will include your applet. The following simple HTML file will do.

<HTML>
<HEAD>
<TITLE> Hello World </TITLE>
</HEAD>

<BODY>
This is the applet:<P>
<APPLET codebase="classes" code="HelloWorldApplet.class" width=200 height=200 ></APPLET>
</BODY>
</HTML>
Save this file as "HelloWorldApplet.html" in the javahtml directory. When you've done that load the HTML file into a Java enabled browser such as HotJava or Netscape 2.0. You should see the following:

This is the applet:
Hello World!
If the applet compiled without error and produced a HelloWorldApplet.class file, and yet you don't see the string "Hello World" in your browser chances are that the class file is in the wrong place. Make sure the .html file is in the javahtml directory and the compiled .class file is in the javahtml/classes directory.

Examining the Hello World Applet

The Hello World Applet adds several constructs to what we saw in the Hello World Application. Moving from top to bottom the first thing you notice is the two lines:

import java.applet.Applet;    
import java.awt.Graphics;
The import statement in Java is similar to the #include statement in C or C++. It pulls in the classes that are contained in a package elsewhere. A package is merely a collection of related classes. In this case we're requesting access to the public classes contained in the basic release, java.applet.Applet and java.awt.Graphics. Depending on the phase of the moon, awt stands for "advanced window toolkit" or "applet window toolkit". You'll see a lot more of it.

The next change from the application is the Class definition:

public class HelloWorldApplet extends Applet

The extends keyword indicates that this class is a subclass of the Applet class; or, to put it another way, Applet is a superclass of HelloWorldApplet. The Applet class is defined in the java.applet.Applet package which we just imported. Since HelloWorldApplet is a subclass of the Applet class, our HelloWorldApplet automatically inherits all the functionality of the generic Applet class. Anything an Applet can do, the HelloWorldApplet can do too.

The next difference between the applet and the application is far less obvious (except maybe to a longtime C programmer). There's no main method! Applets don't need them. The main method is actually in the browser or the AppletViewer, not in the Applet itself. Applets are like plugin code modules for Adobe Photoshop that provide extra functionality, but can't run without a main program to host them.

Rather than starting at a specific place in the code applets are event driven. An applet waits for one of a series of events such as a key press, the mouse pointer being moved over the applets visible area, or a mouse click and then executes the appropriate event handler. Since this is our first program we only have one event handler, paint.

Most applets need to handle the paint event. This event occurs whenever a part of the applet's visible area is uncovered and needs to be drawn again.

The paint method is passed a Graphics object which we've chosen to call g. The Graphics class is defined in the java.awt.Graphics package which we've imported. Within the paint method we call g's drawString method to draw the string "Hello World!" at the coordinates (50,25). That's 50 pixels across and twenty-five pixels down from the upper left hand corner of the applet. We'll talk more about coordinate systems later. This drawing takes place whenever a portion of the screen containing our applet is covered and then uncovered and needs to be refreshed.

The APPLET HTML Tag

Applets are included on web pages using the <APPLET> tag. The <APPLET> tag is perhaps most similar to the <IMG> tag. Like <IMG> <APPLET> needs to reference a source file that is not part of the HTML page on which it is embedded. IMG's do this with the SRC= parameter. APPLET's do this with the CODE= parameter. The CODE parameter tells the browser where to look for the compiled .class file. It is relative to the location of the source document. Thus if you're browsing http://metalab.unc.edu/javafaq/index.html and that page references an applet with CODE=animation.class, then the animation.class file needs to be at http://metalab.unc.edu/javafaq/animation.class.
For reasons that remain a mystery to HTML authors everywhere, but possibly having something to do with packages and classpaths, if the applet resides somewhere other than the same directory as the page it lives on, then you don't just give a URL to its location. Rather you point at the directory where the .class file is using the CODEBASE parameter. You still also have to use CODE to give name of the .class file.

Also like IMG, APPLET has several parameters to define how it is positioned on the page. HEIGHT and WIDTH parameters work exactly as they do with IMG, specifying how big a rectangle the browser should leave for the applet. These numbers are specified in pixels. ALIGN also works exactly as for images (in those browsers that support ALIGN) defining how the applet's rectangle is placed on the page relative to other elements. Possible values include LEFT, RIGHT, TOP, TEXTTOP, MIDDLE, ABSMIDDLE, BASELINE, BOTTOM and ABSBOTTOM. Finally as with IMG you can specify an HSPACE and a VSPACE in pixels to set the amount of blank space between an applet and the surrounding text.

Finally also like IMG, APPLET has an ALT tag. As far as I know ALT is not yet implemented in any browsers. An ALT tag is used by a browser that understands the APPLET tag but for some reason cannot play the applet. For instance if an applet needs to write a file on your hard drive, but your preferences are set not to allow that, then the browser should display the ALT text.

ALT is not used for browsers that do not understand APPLET at all. For that purpose APPLET has been defined to include a closing tag as well, </APPLET>. All raw text between the opening and closing APPLET tags is ignored by a Java capable browser. However a non-Java capable browser will ignore the APPLET tags instead and read the text between them.

Passing Parameters to Applets

The area between the opening and closing APPLET tag is also used to pass parameters to applets. This is done through the use of the PARAM HTML tag and the getParameter method of the java.applet.Applet class.

To demonstrate this we'll convert HelloWorldApplet into a generic string drawing applet. To do this we'll need to pass the applet parameters that define the string to be drawn.

import java.applet.Applet;    
import java.awt.Graphics; 
             
public class DrawStringApplet extends Applet {

  String input_from_page;

  public void init() {
    input_from_page = getParameter("String");
  }
  
  public void paint(Graphics g) {
    g.drawString(input_from_page, 50, 25);
  }
  
}
Now you need to create an HTML file that will include your applet. The following simple HTML file will do:
<HTML>
<HEAD>
<TITLE> Draw String </TITLE>
</HEAD>

<BODY>
This is the applet:<P>
<APPLET codebase="classes" code="DrawStringApplet.class" width=200 height=200><PARAM name="String" value="Howdy, there!"></APPLET>
</BODY>
</HTML>
Of course you are free to change "Howdy, there!" to a string of your choice. Note that this allows you to change the output of the applet without changing or recompiling the code.
You're not limited to one parameter either. You can pass as many named parameters to an applet as you like.

The getParameter method is straightforward. You give it a string that's the name of the parameter you want. You get back a string that's the value of the parameter. All parameters are passed as Strings. If you want to get something else like an integer then you'll need to pass it as a String and convert it into the type you really want.

The PARAM HTML tag is also straightforward. It occurs between <APPLET> and </APPLET>. It has two parameters of its own, NAME and VALUE. The NAME identifies which parameter this is for the getParameter method. VALUE is the value of the parameter as a String. Both must be enclosed in double quote marks like all other HTML tag parameters.

Events and Applets

Event Tutor Applet

The following applet is designed to give you some feel for just what event driven programming is like and what the various events you're likely to encounter are. Whenever an event occurs, the applet responds by printing the name of the event at the command line.
import java.applet.Applet;
import java.awt.*;
              
public class EventTutor extends Applet {

  public void init() {
    System.out.println("init event");
  }
  
  public void paint(Graphics g) {
    System.out.println("paint event");
  }
    
  public void start() {
    System.out.println("start event");
  }
 
  public void destroy() {
    System.out.println("destroy event");
  }
 
  public void update(Graphics g) {
    System.out.println("update event");
  }
  
  public boolean mouseUp(Event e, int x, int y) {
    System.out.println("mouseUp event");
    return false;
  }
  
  public boolean mouseDown(Event e, int x, int y) {
   System.out.println("mouseDown event");
   return false;
  }
  
  public boolean mouseDrag(Event e, int x, int y) {
    System.out.println("mouseDrag event");
        return false;
  }
  
  public boolean mouseMove(Event e, int x, int y) {
    System.out.println("mouseMove event");
    return false;
  }
  
  public boolean mouseEnter(Event e, int x, int y) {
    System.out.println("mouseEnter event");
    return false;
  }
  
 public boolean mouseExit(Event e, int x, int y) {
    System.out.println("mouseExit event");
    return false;
  }
  
  public void getFocus() {
    System.out.println("getFocus event");
  }
  
  public void gotFocus() {
    System.out.println("gotFocus event");
  }
  
  public void lostFocus() {
    System.out.println("lostFocus event");
  }
  
  public boolean keyDown(Event e, int x) {
    System.out.println("keyDown event");
    return true;
  }
  
}
Once you've compiled and loaded this applet play with it. Click the mouse in the applet window. Doubleclick the mouse. Click and drag. Type some text. Resize the browser window. Cover it and then uncover it. Keep your eye on the standard output (Java console in Netscape) while doing this.
Here are some questions to answer:

Can you have a mouseDown event that is not followed by a mouseUp event?
Can you have a mouseDown event that is not followed by a mouseDrag event?
Can you have a mouseUp Event that is not preceded by a mouseDown event?
What has to happen for a paint event to occur?
What's the most common event? Why?
Are there any events you don't see?
How many times can you make the start event get called? the stop event?
Of those events you can make occur, exactly how do you do it? How many different ways can you do it? There are a number of new things in this code but none of them are particularly difficult. The first one is the second import statement, import java.awt.*. This time we need more than one class from the awt package so rather than worrying about which one to import, we just get them all with the *. The compiler is smart enough to only link in those that it actually uses.
Finally there are a whole lot of new event methods. We'll cover them in detail in the next section. For now see under what circumstances you can make each one happen.

Making a List

It is extremely bad form to use System.out.println() in an applet. On some systems this may not work at all. However it has the advantage of being familiar and easy. For more serious work you should actually draw your text in the applet window. There are at least three different ways to do this. For our purposes the one that makes the most sense is to use a List.

A List is a scrolling list of Strings defined in java.awt.List. We create a new List with new, just as we create any other Object. The specific constructor we use asks for an int that's the number of visible lines and a boolean that tells whether or not multiple selections are allowed. We'll ask for 25 lines and no multiple selections.


 List theList; 
 theList = new List(25, false);
We add Strings to the list by using the addItem method of the List we're adding to like so:


    theList.addItem("This is a list item");
Finally we need to actually add this List to our applet (more precisely the applet's container). We do this with the line


    add(theList);
in the init method. That's all. We can use the same applet we used before with these simple changes.

import java.applet.Applet;
import java.awt.*;
              
public class EventList extends Applet {

  List theList; 

  public void init() {
    theList = new List(25, false);
    add(theList);
    theList.addItem("init event");
  }
  
  public void paint(Graphics g) {
    theList.addItem("paint event");
  }
    
  public void start() {
    theList.addItem("start event");
  }
 
  public void destroy() {
    theList.addItem("destroy event");
  }
 
  public void update(Graphics g) {
    theList.addItem("update event");
  }
  
  public boolean mouseUp(Event e, int x, int y) {
    theList.addItem("mouseUp event");
    return false;
  }
  
  public boolean mouseDown(Event e, int x, int y) {
   theList.addItem("mouseDown");
   return false;
  }
  
  public boolean mouseDrag(Event e, int x, int y) {
    theList.addItem("mouseDrag event");
        return false;
  }
  
  public boolean mouseMove(Event e, int x, int y) {
    theList.addItem("mouseMove event");
    return false;
  }
  
  public boolean mouseEnter(Event e, int x, int y) {
    theList.addItem("mouseEnter event");
    return false;
  }
  
 public boolean mouseExit(Event e, int x, int y) {
    theList.addItem("mouseExit event");
    return false;
  }
  
  public void getFocus() {
    theList.addItem("getFocus event");
  }
  
  public void gotFocus() {
    theList.addItem("gotFocus event");
  }
  
  public void lostFocus() {
    theList.addItem("lostFocus event");
  }
  
  public boolean keyDown(Event e, int x) {
    theList.addItem("keyDown event");
    return true;
  }
  
}
We'll talk more about containers, Lists, and applet components in a later section.

The Events

In this section we're going to categorize the events your applet should respond to. You may not always need to respond to each one. For some of the events we'll also include new methods for the EventTutor applet that show a little more information. When we do you should replace the old method with the new one.

init
The init() method is called when your applet begins executing. Netscape is also known to call this method at other times such as when an applet is reloaded or you return to a page containing an applet. Generally you use this method to set up any data structures or perform any tasks you need to get ready to run the applet. Since it's only called once it's easy to miss the init() method in the EventTutor applet. If necessary redirect the standard output to a file and look at the first line of that file to see it.
  public void init() {
    System.out.println("init event");
  }
paint
We've already seen the paint() method. Almost any applet is going to need to override this method. This is the method in which you will do all your drawing. You can only write to the applet screen in the paint method. However there are times when you'll want to write to an offscreen image in another method and then just quickly copy that image to the screen in your paint() method.
  public void paint(Graphics g) {
    theList.addItem("paint event");
  }
stop
A stop() message says the user is no longer looking at the page that contains the applet. This is usually because the user left the page or minimized the window. At this time you should stop any CPU eating activities that don't matter when the user isn't looking at your page. For instance your Doom applet should stop tracking monster movement if the user isn't actually playing. On the other hand a spreadsheet applet in the middle of a long calculation should continue calculating because the user is likely to want the result later. Once the user returns to the page the start() method is called.
  public void stop() {
    theList.addItem("stop event");
  }
start
The start() method is called when a user brings their attention back to an applet, for instance after maximizing a window or returning to the applet's page. It is called after the init() method. Initialization code that needs to be performed every time an applet is restarted should be put here.
  public void start() {
    theList.addItem("start event");
  }
destroy
The destroy() method is called before the applet is unloaded completely. It is called after the stop() method. Users may reload the applet later, but if they do it will be as if they've never seen it before. All variables, static, member, local or otherwise will be initialized to their initial state. If you have any final cleanup to do (for instance sending output back to the httpd server) do it here.
  public void destroy() {
    theList.addItem("destroy event");
  }
update
The update() method is called automatically by the system when ????. It's often overridden when you want to use offscreen Images to avoid flicker.
  public void update(Graphics g) {
    theList.addItem("update event");
  }
mouseUp
The mouseUp() method is called whenever the mouse button is released in your applet. In most cases this is the event you'll want to watchout for, not mouseDown. A button is typically highlighted when the mouse button is pressed on it, but it is not activated till the user releases the mouse button. This gives the user a chance to change their mind by moving the cursor off the object without releasing it.
The exception would be when you want an action to continue as long as the mouse button is held down, a fast forward button on a movie playing applet for instance.

mouseUp() methods also receive the coordinates of the point where the mouse was released.

  public boolean mouseUp(Event e, int x, int y) {
    theList.addItem("mouseUp event at (" + x + "," + y + ")");
    return false;
  }
mouseDown
The mouseDown() method is called whenever the mouse button is pressed in your applet. In most cases you'll want to wait for a mouseUp before taking any action though.
mouseDown() methods also receive the coordinates of the point where the mouse was released.

  public boolean mouseDown(Event e, int x, int y) {
    theList.addItem("mouseDown event at (" + x + "," + y + ")");
    return false;
  }
mouseDrag
mouseDrag() methods occur when a user moves the mouse while holding down the mouse button. mouseDrag() methods receive the coordinates of the point where the mouse is when the event occurs.
  public boolean mouseDrag(Event e, int x, int y) {
    theList.addItem("mouseDrag event at (" + x + "," + y + ")");
        return false;
  }
mouseMove
mouseMove methods occur when a user moves the mouse without holding down the mouse button. mouseMove methods receive the coordinates of the point where the mouse is when the event occurs.
  public boolean mouseMove(Event e, int x, int y) {
    theList.addItem("mouseMove event at (" + x + "," + y + ")");
    return false;
  }
mouseEnter
Your applet receives a mouseEnter event whenever the cursor enters your applet from somewhere else. You'll also receive the coordinates of the point at which the cursor entered your applet. After this happens its typically followed by a Stream of mouseMoved events as the cursor continues through the applet so it can be hard to see.
  public boolean mouseEnter(Event e, int x, int y) {
    theList.addItem("mouseEnter event at " + x + "," + y + ")");
    return false;
  }
mouseExit
Your applet receives a mouseExit event whenever the cursor leaves your applet. You'll also receive the coordinates of the point at which the cursor exited your applet.
 public boolean mouseExit(Event e, int x, int y) {
    theList.addItem("mouseExit event at (" + x + "," + y + ")");
    return false;
  }
getFocus
  public void getFocus() {
    theList.addItem("getFocus event");
  }
gotFocus
public void gotFocus() { theList.addItem("gotFocus event"); }
lostFocus
  public void lostFocus() {
    theList.addItem("lostFocus event");
  }
keyDown
A keydown event is generated whenever the user presses a key while your applet is active. An integer keycode is returned indicating which key was pressed. As a general rule you'll want to cast this to a char to get the actual letter.
  public boolean keyDown(Event e, int x) {
    theList.addItem("The " + (char) x + " key was pressed.");
    return false;
  }
Here's the revised EventTutor Applet:

Drawing Text

Drawing Graphics: Lines, Circles, Rectangles and Colors

Drawing Rectangles

Next we'll write an applet that fills the screen with lots of randomly sized and positioned rectangles in the style of Piet Mondrian. In the process we'll learn the basics of applet graphics. We're going to take this one step at a time, adding a bit as we go.
In the first applet we'll just draw a rectangle on the screen. We'll get the size of the applet as specified in the HTML file, and then we'll draw a rectangle around the applet to frame it. Here's the code:

//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian1 extends Applet {

  int height, width;

  public void init() {
  
    Dimension d = size();
    height = d.height;
    width = d.width;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, width, height);
    
  }

}
Compile this applet; move the resulting class file to your classes directory, and create an HTML file that points to it. Set the height of the applet to 300 pixels and the width to 300 pixels as well. Load that file into your browser and what do you see? Probably not what you expected. You should see half a rectangle. What happened to the other half?
This is called a fencepost error. The applet lives in a square 300 pixels tall by 300 pixels wide. However the upper left hand corner of the applet starts at (0, 0), not at (1, 1). This means that the applet includes the points with x and y coordinates between 0 and 299, not between 0 and 300. We drew a rectangle 301 pixels high and 301 pixels wide so the edges were chopped off.

This is fortuitous however. Not only does it allow me the opportunity to digress on fencepost errors (which, although annoying, are far less dangerous in Java than in C since Java does check array boundaries) but it also shows us something else. In Java the coordinate system for an applet begins in the upper left hand corner and increases to the right and down. This is common in computer graphics but is different from the Cartesian coordinate system where the direction of increasing y is generally assumed to be up.

Correcting the fence post error is easy. We just change g.drawRect(0, 0, width, height); to g.drawRect(0, 0, width-1, height-1);

//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian2 extends Applet {

  int height, width;

  public void init() {
  
    Dimension d = size();
    height = d.height;
    width = d.width;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, width-1, height-1);
    
  }

}
As usual compile this and load it into your browser. If the problem isn't fixed check to make sure that you moved the new class file into the classes directory and that you modified the HTML file to point to Mondrian2.
We've introduced exactly one new statement in all this code, drawRect which is a method in the Graphics class. The line g.drawRect(0, 0, height-1, width-1) instructs the Graphics class g to draw a rectangle beginning at the point (0, 0) and ending at the point (299, 299).

This particular rectangles encompasses the entire applet's visible space. There is nothing to keep us from drawing outside the applet, in fact we did exactly that in our first version where we actually extended the rectangle to (300, 300); but anything we draw there won't be seen by the user.

The drawRect method draws an open rectangle. If we want to draw a filled rectangle we use the fillRect method. Otherwise the syntax is identical. In Mondrian3 we'll draw a filled rectangle in the center of the applet. Here's the code:

//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian3 extends Applet {

  int AppletHeight;
  int AppletWidth;
  int RectHeight;
  int RectWidth;
  int RectTop;
  int RectLeft;


  public void init() {
  
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectHeight = AppletHeight/3;
    RectWidth = AppletWidth/3;
    RectTop = (AppletHeight - RectHeight)/2;
    RectLeft= (AppletWidth - RectWidth)/2;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
    
  }

}
This latest example also demonstrates one other thing. Until now you may have thought that we were passing two points to the drawRect and fillRect methods and drawing the rectangle that joins them. This is how rectangles are implemented in QuickDraw on the Mac for example. However if that was the case the preceding rectangle would have been drawn between (100, 100) and (100, 100), a fairly small rectangle. Since that isn't the case our association of the last two variables with width and height must be correct.
The extremely astute reader may object at this point. Until now we've only drawn squares. Although the last two variables passed to drawRect and fillRect must be the height and the width how do we know which is which? The simplest way to tell is to write a test program that draws a non-square rectangle. Let's try that now:

//Draw a rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian4 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectHeight = AppletHeight/3;
    RectWidth = (AppletWidth*2)/3;
    RectTop = (AppletHeight - RectHeight)/2;
    RectLeft= (AppletWidth - RectWidth)/2;

    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }

}
So you see that the third argument is indeed the width and the fourth is the height.
Now that we've learned how to draw rectangles, both filled and unfilled, let's make life a little more exciting by randomly selecting the position and size of the rectangle. To do this we'll need the Math.random() method from java.lang.Math. This method returns a double between 0.0 and 1.0 so we'll need to multiply the result by the applet's height and width to get a reasonably sized rectangle that fits into our applet space. To do this we'll create the following Randomize method:

private int Randomize( int range )
{
  double  rawResult;
  
  rawResult = Math.random();
  return (int) (rawResult * range);

}
This method forces the result of Math.random into an int in the range we require. Pay special attention to the last line. When you see a raw type in parentheses like (int) or (float) it's a cast. Casts change one value type into another. Thus here we're changing a double into an int. The cast rounds as necessary.
Casting in Java is safer than in C or other languages that allow arbitrary casting. Java only lets casts occur when they make sense, such as a cast between a float and an int. However you can't cast between an int and a String for example.

//Draw a rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian5 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);

    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
Occasionally this applet does randomly produce a rectangle that's two small to see so if you don't see anything, reload it. Reload it a few times. Each time you'll see a rectangle of a different size appear in a different place.
Let's make our world a little more colorful. To do this we'll change the rectangle color to red. To do this we'll use a new methods setColor(), part of the Graphics class.

//Draw a colored rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian6 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);

    repaint();

  }

  public void paint(Graphics g) {

   // g.setBackground(Color.white);
    g.setColor(Color.red);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
The awt predefines a number of colors including:
black
blue
cyan
darkGray
gray
green
lightGray
magenta
orange
pink
red
white
yellow
If these aren't sufficient for your needs, you can define others using the same RGB triple that's used to set background colors on many web pages. You even get to use decimal numbers instead of the hex values you have to use for the bgcolor tag. For example to select a medium gray you'd use Color(127, 127, 127). Pure white would be Color(255, 255, 255). Pure red is (255, 0, 0) and so on.
By using the color constructor we can expand our program to select not only a random rectangle but also a random color for the rectangle. Here's the code:

//Draw a randomly colored rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian7 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);
    RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));

    repaint();

  }

  public void paint(Graphics g) {

   // g.setBackground(Color.white);
    g.setColor(RectColor);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
In the next example we're going to draw multiple randomly sized, randomly colored rectangles. Since we want each rectangle to be different we're going to have to move the calculation of the rectangle's shape, position and color into the paint() method. Here's the code:
//Draw many randomly colored rectangles

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian8 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  int numberRectangles = 100;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;

    repaint();

  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i < numberRectangles; i++)  {
      RectTop = Randomize(AppletHeight);
      RectLeft= Randomize(AppletWidth);
      RectHeight = Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
  }
  
 }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
Finally let's let the HTML specify the number of rectangles to be drawn in one pass. We'll keep the default value as is and only replace it if the HTML includes a Number PARAM.
//Draw many random rectangles

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian9 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  int numberRectangles = 100;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    String s = getParameter("Number");
    if (s != null) {
      numberRectangles = Integer.valueOf(s).intValue();
  }
  
    repaint();

  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i < numberRectangles; i++)  {
      RectTop = Randomize(AppletHeight);
      RectLeft= Randomize(AppletWidth);
      RectHeight = Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
  }
  
 }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
That's all for now, but we'll return to Mondrian at the end of this chapter when we add threading, and show how to draw rectangles continuously.
Exercises

For the artistically inclined: write a version of Mondrian that draws pictures that are more believably in the style of Piet Mondrian. You should probably restrict your color choices and not allow rectangles to overlap.
Drawing Lines

The awt contains several graphics primitives. Rectangles are one and we've pretty much beaten them into the ground in the previous section. Lines are another. Within a graphics context there is one key line drawing method, drawLine(int x1, int y1, int x2, int y2). This method draws a straight line between the point (x1, y1) and the point (x2, y2). Here's a simple applet that draws a line diagonally across the applet frame:
import java.applet.Applet;    
import java.awt.*; 

public class SimpleLine extends Applet {

  int AppletHeight, AppletWidth;

  public void init() { 
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
  }

 public void paint(Graphics g) {
 
    g.drawLine(0, 0, AppletWidth, AppletHeight);
  
 }

}
Graphing Functions

We're now going to demonstrate the use of the drawLine() method to draw considerably non-straight figures. It is shown in advanced calculus that any reasonably well-behaved (should that be differentiable?) function can be approximated arbitrarily well by straight lines where quantities like &well-behaved" and "arbitrarily are precisely defined. I'll spare you the details of the mathematical proof, but I will demonstrate its probability to you by producing an applet that does a very good job of graphing any function you care to throw at it. As usual we'll develop it in pieces rather than just throwing it all out at once.
We begin with the skeleton applet. We'll need to add some code to the paint method of the applet to make it draw something. Let's begin by drawing a sine wave from the left hand side of the image to the right hand side. Here's the complete program:

import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;

  public void init() {
    // How big is the applet?
    Dimension d = size();
  
    x0 = 0;
    xN = d.width-1;
    y0=0;
    yN=d.height-1;
  }
  
  public void paint(Graphics g) {

    for (int x = x0; x < xN; x++) {
      g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1)));
    }

  }
  
}
The meat of this applet is in the for loop of the paint method.
    for (int x = x0; x < xN; x++) {
      g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1)));
    }
Here we loop across every x pixel of the applet. At each one we calculate the sine of that pixel. We also calculate the sine of the next pixel. This gives us two 2-D points and we draw a line between them. Since the sine of a real number is always between one and negative one, we scale the y value by yN. Finally we cast the y values to ints since sines are fundamentally floating point values but drawLine requires ints.
This applet runs but it's got a lot of problems. All of them can be related to two factors:

Sines are floating point operations. To do a really useful graphing applet we need to be able to use floating point numbers.
The coordinate system of an applet counts from (0,0) at the upper left hand corner to the right and down. The standard Cartesian coordinate system we expect graphs to use counts from (0,0) in the lower left hand corner to the right and up. The origin can be moved in both systems, for instance to the center of the applet, but we still need to transform between the y down and the y up coordinates.
There are a number of ways we can resolve this. The key to all of them, however, is to separate the data from the display. Since we are graphing more or less well behaved mathematical functions, we can assume that our data is completely described by a rectangle in Cartesian space within which we wish to plot a function. The display, on the other hand, is described by a rectangle of discrete points of fixed size and width. We need to be able to calculate in the general Cartesian plane and display in the particular applet window.

We'll need a method that will convert a point in the applet window into a point in the Cartesian plane, and one that will convert it back. Here it is:

import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;
  double xmin, xmax, ymin, ymax;
  int AppletHeight, AppletWidth;

  public void init() {
    // How big is the applet?
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth  = d.width;
    x0 = 0;
    xN = AppletWidth-1;
    y0=0;
    yN=AppletHeight-1;
    xmin = -10.0;
    xmax =  10.0;
    ymin = -1.0;
    ymax =  1.0;
  }
  
  public void paint(Graphics g) {
  
    double x1,y1,x2,y2;
    int i, j1, j2;

    j1 = yvalue(0);
    for (i = 0; i < AppletWidth; i++) {
      j2 = yvalue(i+1);
      g.drawLine(i, j1 ,i+1, j2);
      j1 = j2;
    }

  }
  
  private int yvalue(int ivalue)  {
  
    // Given the  xpoint we're given calculate the Cartesian equivalent
    double x, y;
    int jvalue;
    
    x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin;
    
    // Take the sine of that x 
    y = Math.sin(x);
    
    // Scale y into window coordinates
    jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin));
  
    // Switch jvalue from cartesian coordinates to computer graphics coordinates    
    jvalue = AppletHeight - jvalue;
    
    return jvalue;
  
  }


  
}
Run this applet. Isn't that a much nicer looking sine wave? There are still a number of things we can add to make this a more complete applet though. The most important would be to add some parameters so that we can define the size of the applet in HTML. The following modification of the init and paint methods looks for xmin, xmax, ymin, and ymax to be specified via parameters. However for robustness if the author of the HTML forgets to specify them we supply some reasonable default values.
import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;
  double xmin, xmax, ymin, ymax;
  int AppletHeight, AppletWidth;

  public void init() {
    String ParamString;
  
    // How big is the applet?
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth  = d.width;
    x0 = 0;
    xN = AppletWidth-1;
    y0=0;
    yN=AppletHeight-1;    

    ParamString = getParameter("xmin");
    if (ParamString != null) {
      xmin = Double.valueOf(ParamString).doubleValue();
    }
    else {
      xmin = -1.0;
    }
    ParamString = getParameter("xmax");
    if (ParamString != null) {
      xmax = Double.valueOf(ParamString).doubleValue();
    }
    else {
      xmax = 1.0;
    }
    ParamString = getParameter("ymax");
    if (ParamString != null) {
      ymax = Double.valueOf(ParamString).doubleValue();
    }
    else {
      ymax = 1.0;
    }
    ParamString = getParameter("ymin");
    if (ParamString != null) {
      ymin = Double.valueOf(ParamString).doubleValue();
    }
    else {
      ymin = -1.0;
    }
  }

  public void paint(Graphics g) {
  
    double x1,y1,x2,y2;
    int i, j1, j2;

    j1 = yvalue(0);
    for (i = 0; i < AppletWidth; i++) {
      j2 = yvalue(i+1);
      g.drawLine(i, j1 ,i+1, j2);
      j1 = j2;
    }

  }
  
  private int yvalue(int ivalue)  {
  
    // Given the  xpoint we're given calculate the Cartesian equivalent
    double x, y;
    int jvalue;
    
    x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin;
    
    // Take the sine of that x 
    y = Math.sin(x);
    
    // Scale y into window coordinates
    jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin));
  
    // Switch jvalue from cartesian coordinates to computer graphics coordinates    
    jvalue = AppletHeight - jvalue;
    
    return jvalue;
  
  }
  
}
Now we can adjust the range over which we graph without modifying our code!
So far we've only graphed sine functions. It should be obvious how to modify the code to graph cosines or many other kinds of functions. However what if we want to define the function at runtime?

Exercises

Add labeled coordinate axes to the graph.
Our graph method handled mathematical functions. How would you need to change it and what features would you add to make it suitable for plotting discrete experimental data?
An infinite set that with zero length

We're now going to use Java to implement some classic examples of fractal geometry. We'll do three of these. We begin with a one-dimensional set with an infinite number of points that covers zero length. Then we'll investigate the Koch snowflake. Finally in the next chapter we'll delve into the most famous fractal of all, the Mandelbrot set.
The middle third set is defined by starting with all the real numbers between zero and one inclusive. Then we cut out the middle third of that set (exclusive of the endpoints). i.e. everything between one third and two thirds exclusive.

Next we cut the middle third of the two line segments that remain, i.e. everything between one ninth and two ninths and between seven ninths and eight ninths. We continue this process indefinitely.

Was that confusing? Good. A picture is worth a thousand words and a good Java program is worth a thousand pictures. We now proceed to show you a Java program that draws successive pictures to demonstrate the middle third set.


import java.applet.Applet;    
import java.awt.*;
import java.util.Vector;

public class MiddleThird extends Applet {

int AppletWidth;
int AppletHeight;

Vector endpoints = new Vector();

  public void init() { 
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    endpoints.addElement(new Float(0.0f));
    endpoints.addElement(new Float(1.0f));  
  }

 public void paint(Graphics g) {
 
   float x1, x2;
   Float tempFloat;
   for (int i = 0; i <  AppletHeight; i+= 5) {
     // draw the lines
     for (int j=0; j < endpoints.size(); j += 2) {
       tempFloat = (Float) endpoints.elementAt(j);
       x1 = tempFloat.floatValue();
       tempFloat = (Float) endpoints.elementAt(j+1);
       x2 = tempFloat.floatValue();
       g.drawLine( Math.round(x1*AppletWidth), i, Math.round(x2*AppletWidth), i);
     }
     //remove the middle third of the lines
     CutSegments();
     // Now check to see if we've exceeded the resolution of our screen
     tempFloat = (Float) endpoints.elementAt(0);
     x1 = tempFloat.floatValue();
     tempFloat = (Float) endpoints.elementAt(1);
     x2 = tempFloat.floatValue();
     if (Math.round(x1*AppletWidth) == Math.round(x2*AppletWidth)) break;
   }
  
   
 }

 private void CutSegments() {

   int index = 0;
   float gap;
   float x1, x2;
   Float tempFloat1, tempFloat2;
   int stop = endpoints.size();
   
   for (int i=0; i < stop; i+=2) {
      CutMiddleThird(index, index+1);
      index += 4;
   }
   
 }
 
 
  private void CutMiddleThird(int left, int right) {

   float gap;
   float x1, x2;
   Float tempFloat1, tempFloat2;
   
   tempFloat1 = (Float) endpoints.elementAt(left);
   tempFloat2 = (Float) endpoints.elementAt(right);
   gap = tempFloat2.floatValue() - tempFloat1.floatValue();
   x1  = tempFloat1.floatValue() + gap/3.0f;
   x2  = tempFloat2.floatValue() - gap/3.0f;
   endpoints.insertElementAt(new Float(x2), right);
   endpoints.insertElementAt(new Float(x1), right);
   
 }

}
Compile and load this applet. Is that clearer? Of course this isn't a perfect representation of the middle third set since we have to deal with points of finite size rather than with genuine mathematical points. Depending on how large a window you give your applet, you will probably only see about six to twelve iterations before we need to start working with fractional pixels.
Flying Lines

The next example is harder to describe than it is to code. Like Mondrian it runs in an infinite loop but it's a little more than random images. Compile the following code, run it and then look over the code to see if you can understand the algorithm.
//Bounce lines around in a box

import java.applet.Applet;    
import java.awt.*; 
        
public class FlyingLines extends Applet {

  int NUM_LINES = 25;
  int gDeltaTop=3, gDeltaBottom=3;
  int gDeltaLeft=2, gDeltaRight=6;
  int AppletWidth, AppletHeight;
  int gLines[][] = new int[NUM_LINES][4];

  public void init() {

    AppletWidth = size().width;
    AppletHeight = size().height;

  }
  
  public void start() {
    gLines[0][0] = Randomize(AppletWidth);
    gLines[0][1] = Randomize(AppletHeight);
    gLines[0][2] = Randomize(AppletWidth);
    gLines[0][3] = Randomize(AppletHeight);
    for (int i=1; i < NUM_LINES; i++ ) {
      LineCopy(i, i-1);
      RecalcLine(i);
    } 
    repaint();
  
  }

  public void paint(Graphics g) {

     while (true) {
      for (int i=NUM_LINES - 1; i > 0; i--) {
        LineCopy(i, i-1);
      }
      RecalcLine(0);
      g.setColor(Color.black);
      g.drawLine(gLines[0][0], gLines[0][1], gLines[0][2], gLines[0][3]);
      g.setColor(getBackground());
      g.drawLine(gLines[NUM_LINES-1][0], gLines[NUM_LINES-1][1], 
        gLines[NUM_LINES-1][2], gLines[NUM_LINES-1][3]);
    }
    
  }

  private void LineCopy (int to, int from)  {

    for (int i = 0; i < 4; i++) {
      gLines[to][i] = gLines[from][i];
    }

  }

  public int Randomize( int range ) {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

  private void RecalcLine( int i ) {

    gLines[i][1] += gDeltaTop;
    if ((gLines[i][1] < 0) || (gLines[i][1] > AppletHeight)) {
      gDeltaTop *= -1;
      gLines[i][1] += 2*gDeltaTop;
    }

    gLines[i][3] += gDeltaBottom;
    if ( (gLines[i][3] < 0) || (gLines[i][3] > AppletHeight) ) {
      gDeltaBottom *= -1;
      gLines[i][3] += 2*gDeltaBottom;
    }

    gLines[i][0] += gDeltaLeft;
    if ( (gLines[i][0] < 0) || (gLines[i][0] > AppletWidth) ) {
      gDeltaLeft *= -1;
      gLines[i][0] += 2*gDeltaLeft;
    }

    gLines[i][2] += gDeltaRight;
    if ( (gLines[i][2] < 0) ||  (gLines[i][2] > AppletWidth) ) {
      gDeltaRight *= -1;
      gLines[i][2] += 2*gDeltaRight;
    }
    
  }  //RecalcLine ends here

} // FlyingLines ends here
Taking Action: Threads

Depending on your operating system and Java-enabled browser you may have noticed that the Mondrian and Flying Line programs tended to hog your CPU. On Windows NT HotJava stopped responding to my commands several thousand iterations into Mondrian, and I had to kill it from the Task List.
The paint loops in both Mondrian and FlyingLines are ideal for a thread, a separate stream of execution that takes place simultaneously and independently of everything else that might be happening (like responding to the programmer's insistence to "Quit!, Damnit!"). Without threads an entire program can be held up by one CPU intensive task or, as in Flying Lines, one infinite loop, intentional or otherwise.

As a general rule all CPU intensive tasks should be placed in their own threads. Here's one way to do it.

//Draw infinitely many random rectangles

import java.applet.Applet;    
import java.awt.*; 

public class ThreadedMondrian extends Applet implements Runnable {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  Thread kicker = null;
  int pause;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    repaint();
  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i < 10; i++) {
      RandomRect();
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
    } 
  
 }
  
  public void run() {
    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

    while (true) {  // infinite loop
      repaint();
      try {
        Thread.sleep(100);
       }
       catch (Exception e) {
       
       }
    }
  }

  public void start() {
    if (kicker == null) {
      kicker = new Thread(this);
      kicker.start();
    }
  }

  public void stop() {
    kicker = null;
  }

  public void RandomRect()  {
      RectTop   = Randomize(AppletHeight);
      RectLeft  = Randomize(AppletWidth);
      RectHeight= Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
  }

  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
We added four key things to Mondrian to make it threaded and a lot more CPU friendly.

We specified that our applet implements Runnable.
We added a run method.
We added a start method.
We added a stop method.
Let's look at them in more detail:

Our applet implements Runnable
Run Method
Start Method
Stop Method
Here's a threaded version of Flying Lines.

//Bounce lines around in a box

import java.applet.Applet;    
import java.awt.*; 
        
public class FlyingLines extends Applet implements Runnable {

  int NUM_LINES = 25;
  int gDeltaTop=3, gDeltaBottom=3;
  int gDeltaLeft=2, gDeltaRight=6;
  int AppletWidth, AppletHeight;
  int gLines[][] = new int[NUM_LINES][4];

  public void init() {

    AppletWidth = size().width;
    AppletHeight = size().height;

  }
  
  public void start() {
    gLines[0][0] = Randomize(AppletWidth);
    gLines[0][1] = Randomize(AppletHeight);
    gLines[0][2] = Randomize(AppletWidth);
    gLines[0][3] = Randomize(AppletHeight);
    for (int i=1; i < NUM_LINES; i++ ) {
      LineCopy(i, i-1);
      RecalcLine(i);
    } 
    repaint();
    Thread t = new Thread(this);
    t.start();
  
  }

  public void run () {
  
    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
  
    while (true) {
      for (int i=NUM_LINES - 1; i > 0; i--) {
        LineCopy(i, i-1);
      }
      RecalcLine(0);
      System.out.println(gLines[0][0] + ", " + gLines[0][1] + "," + gLines[0][2] + ", " + gLines[0][3]);
      repaint();
      try {
        Thread.currentThread().sleep(10);
      }
      catch (Exception e) {
      
      }
    }
  
  }

  public void paint(Graphics g) {

    for (int i=0; i < NUM_LINES; i++) {
      g.drawLine(gLines[i][0], gLines[i][1], gLines[i][2], gLines[i][3]);
    }
    
  }

  private void LineCopy (int to, int from)  {

    for (int i = 0; i < 4; i++) {
      gLines[to][i] = gLines[from][i];
    }

  }

  public int Randomize( int range ) {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

  private void RecalcLine( int i ) {

    gLines[i][1] += gDeltaTop;
    if ((gLines[i][1] < 0) || (gLines[i][1] > AppletHeight)) {
      gDeltaTop *= -1;
      gLines[i][1] += 2*gDeltaTop;
    }

    gLines[i][3] += gDeltaBottom;
    if ( (gLines[i][3] < 0) || (gLines[i][3] > AppletHeight) ) {
      gDeltaBottom *= -1;
      gLines[i][3] += 2*gDeltaBottom;
    }

    gLines[i][0] += gDeltaLeft;
    if ( (gLines[i][0] < 0) || (gLines[i][0] > AppletWidth) ) {
      gDeltaLeft *= -1;
      gLines[i][0] += 2*gDeltaLeft;
    }

    gLines[i][2] += gDeltaRight;
    if ( (gLines[i][2] < 0) ||  (gLines[i][2] > AppletWidth) ) {
      gDeltaRight *= -1;
      gLines[i][2] += 2*gDeltaRight;
    }
    
  }  //RecalcLine ends here

} // FlyingLines ends here
Bozo Sort

Some of the first compelling Java demos were graphical illustrations of several sorting methods including quick sort, bubble sort and bidirectional bubblesort intended to show off the threading capabilities of Java. That's nice, but those methods eventually succeed within our lifetime. For an applet that truly puts threading to good use consider the following bozo sort. In bozo sort the same collection of differently sized sticks is thrown up in the air. If they land in sorted order, the algorithm stops. Otherwise we throw all the sticks in the air again. This algorithm runs in about O(N!) time where N is the number of sticks. It takes effectively infinite time for more than a dozen or so sticks. It's a horrible algorithm but a really great opportunity for threading.


class BozoSortAlgorithm extends SortAlgorithm {

  void sort(int a[]) {
    
    boolean sorted = false;
    
    while (!sorted) {
      int index1 = Randomize(a.length);
      int index2 = Randomize(a.length);  
     
      int temp = a[index2];
      a[index2] = a[index1];
      a[index1] = temp;
      // Is a[] sorted?
      sorted = true;
      for (int i = 1; i < a.length; i++)  {
        if (a[i-1] > a[i]) {
          sorted = false;
          break;
        }  // end if
      }  // end for
    } // end while
  }  // end sort 
   
  private int Randomize( int range )  {

    double  rawResult;
  
    rawResult = Math.random();
    return (int) (rawResult * range);

  }
  
}  // end BozoSortAlgorithm
To actually run this you'll also need the SortItem and SortAlgorithm classes from Sun.

Interaction: Mouse and Keyboard Input

You now have the tools to draw a lot of really cool animations and images on your web pages. This alone puts you leaps and bounds beyond the average web page designer. Still that's only half the point of applets. The other half is interaction with the user. Your applets can accept input from the user and respond to them. For the first time a web surfer can move beyond mere browsing to genuine participation.

Mouse Input: Java Doodle

Here's a simple applet that lets you doodle with the mouse on an applet.

import java.applet.Applet;
import java.awt.*;
import java.util.Vector;

public class JavaDoodle extends Applet {

  Vector points = new Vector();

  
  public void paint(Graphics g) {
  
  	int x1, y1, x2, y2;
  	Point tempPoint;
  
    if (points.size() > 1) {
      tempPoint = (Point) points.elementAt(0);
	  x1 = tempPoint.x;
	  y1 = tempPoint.y;
      for (int i = 1; i < points.size(); i++) {
    	tempPoint = (Point) points.elementAt(i);
	  	x2 = tempPoint.x;
	  	y2 = tempPoint.y;
    	g.drawLine(x1, y1, x2, y2);
    	x1 = x2;
    	y1 = y2;
      } // end for
    } // end if
  }
  
  public boolean mouseDown(Event e, int x, int y) {
    points.addElement(new Point(x, y));
  	return true;
  }

  public boolean mouseDrag(Event e, int x, int y) {
    points.addElement(new Point(x, y));
    repaint();
  	return true;
  }

  public boolean mouseUp(Event e, int x, int y) {
    points.addElement(new Point(x, y));
    repaint();
  	return true;
  }



}
Exercises

Revise the applet so that it doesn't draw a line between the point where the mouse button was released and the point where it was pressed again.
Keyboard Input: TypeWriter

Here's a simple applet that uses the keyDown method to let you type some text.
import java.applet.Applet;    
import java.awt.Event; 
import java.awt.Graphics; 

public class typewriter extends Applet {

  int numcols = 80;
  int numrows = 25;
  int row = 0;
  int col = 0;
  char page[][] = new char[numrows][];

  public void init() {

        for (int i = 0; i < numrows; i++) {
      page[i] = new char[numcols];
    }
    for (int i = 0; i < numrows; i++) {
    	for (int j = 0; j < numcols; j++) {
    	  page[i][j] = '\0';
    	}
    }

  }
  
  
  public boolean keyDown(Event e, int key) {
 
    char c = (char) key;

    switch (key) {
      case Event.HOME:
        row = 0;
        col = 0;
        break;
      case Event.END:
        row = numrows-1;
        col = numcols-1;
        break;
      case Event.UP:
        if (row > 0) row--;
        break;
      case Event.DOWN:
        if (row < numrows-1) row++;
        break;
      case Event.LEFT:
        if (col > 0) col--;
        else if (col == 0 && row > 0) {
          row--;
          col=numcols-1;
        }
        break;
      case Event.RIGHT:
        if (col < numcols-1) col++;
        else if (col == numcols-1 &&  row < numrows-1) {
          row++;
          col=0;
        }
        break;
      default:
        if (c == '\n' || c == '\r') {
          row++;
          col = 0;
        }
        else if (row < numrows) {
          if (col >= numcols) {
    	    col = 0;
    	    row++;
          }
          page[row][col] = c;
          col++;
        }
   	    else { // row >= numrows
   	     col++;
   	    }
   	 }
   	 repaint();
   	 return true;
  } 


  public void paint(Graphics g) {

	for (int i=0; i < numrows; i++) {
	  String tempString = new String(page[i]);	      
      g.drawString(tempString, 5, 15*(i+1));
    }
    
  }

}
Part 4: Objects, Classes, Methods, and Interfaces

What is Object Oriented Programming?

Object Oriented Programming is the programming buzzword of the 90's. Everyone and everything advertises their products as object-oriented. But what does object oriented mean? To understand why object oriented programming is so revolutionary, let's take a brief glance back at the history of computing.

The History of Programming

Programming has always been guided by various methodologies. In the early days of computers, computer memories were quite small. Programs had to be loaded in by toggling switches on a panel. In these days it was possible for a programmer to keep track of every memory location and every machine instruction in his or her head. Since computer memories were so small (often just a few hundred bytes) and the machines so slow, program efficiency was the primary concern. Any program was acceptable as long as it worked. Algorithms were very closely tied to the capabilities of the specific machine they ran on. This is called machine language programming. The toggling of individual memory locations (by switch or other means) is called a first-generation language, and we're being very liberal with the definition of language. In a first generation language there is almost no abstraction.

As computers grew in power and memory, it was no longer possible for a programmer to keep track of what was happening at every location in the machine's physical memory. Card readers and assembly language were invented to make programming more feasible. In assembly language the programmer uses mnemonic codes like MOV to represent particular bit sequences. These codes mapped directly to individual instructions on the CPU, and memory was still addressed directly. One code meant exactly one CPU instruction. (More modern assembly languages don't always map as directly to the CPU as the older ones did.) Algorithmically The philosophy of "Use whatever works" continued.

Assembly language was still a bear to deal with, especially as related to arrays and storage in memory. Therefore the first high-level programming language, Fortran, was invented to spare programmers from the pains of dealing with keeping track of the location of their variables in memory. (It's interesting to note that this lesson has had to be learned again and again and again. The buggiest parts of C and C++ programs result from programmers being allowed to access arbitrary bytes of memory. Java has wisely removed this capability. 99 times out of a 100 you don't need it. A large part of training a C or C++ programmer to use Java, consists of convincing them of this fact.). Fortran was the first example of a third-generation language. In a third generation language you tell the computer the algorithms and data structures it should use to calculate the results you want; but you use more abstract logical and mathematical operators rather than directly manipulating addresses in memory and CPU instructions. In a third generation language, statements represent several machine instructions. Which instructions they represent may even depend on their context.

These languages may be compiled or interpreted. In either case your program code needs to be translated into equivalent machine instructions. This level of abstraction made considerably more powerful algorithms and data structures possible.

Java is a very advanced third generation language. Most of the other computer languages you're probably familiar with, Fortran, Basic, C, C++, Cobol, Pascal, as well as most of the one's you're not familiar with (AppleScript, Frontier, Eiffel, Modula-3, ADA, PL/I, etc.) are also third-generation languages (or 3GL's for short).

When third generation languages were invented, they were supposed to make computers so easy to use even the CEO could write programs. This turned out not to be true. Fourth generation languages (or 4GL's for short) moved the abstraction level a step higher. In these languages you tell the computer what results you want rather telling it how to calculate those results. For instance you would ask for the total sales for the year, without specifying the loops necessary to sum all the sales of all the salespeople. SQL is the most popular fourth generation language.

Of all these languages there's no question that 3GL's have been the most successful by almost any measure. A number of different styles of 3GL programming and programming languages have sprung up, most learning from the experience and mistakes of its predecessors. Fortran (and its cousin Basic) were the first. They shared with assembly language an attitude of "Whatever works, no matter how ugly." They had limited flow control (essentially for loops and goto statements) and one data structure, the array. All variables were global and it was impossible to hide one part of the program from any other. Although it was possible to write maintainable, legible code in these languages, few people did.

Pascal and C were the next widely successful languages. They made possible a style of programming known as structured programming. Structured programming languages have many different flow control constructs (switch statements, while loops, and more) as well as tools for more complicated data structures (structs, records and pointers). Goto is deprecated in structured programming though not eliminated entirely. (It is still necessary for some error handling.) Finally they have subroutines with local variables that are capable of splitting the code into more manageable and understandable chunks. These languages proved more capable of writing larger, more maintainable programs. However they too began to bog down when faced with the need to share code among programmers and to write very large (greater than 50,000 line) programs.

Some of the above history may sound a little funny to those of you with experience in the languages I'm discussing. After all Basic has subroutines and local variables, doesn't it? The fact is successful computer languages have continued to evolve. Fortran now has pointers so it can create more complicated data structures. Basic has while loops. Cobol has objects. And on some architectures like Alpha/VMS the assembly language bears little to no resemblance to the underlying machine architecture. These features were not parts of the first versions of the language, however. And despite these improvements the modern versions of these languages are their parents children. Basic and Fortran programmers still often produce spaghetti code. Assembly language is quick to run but long to program. C is obfuscated beyond the comprehension of mere mortals.

The third generation of 3GL's (3.3 GL's) began to take hold in the late 80's. These were the object oriented languages. Although object oriented languages had been around since the late 1960's, it wasn't until the late 80's that computer hardware became fast enough and memory cheap enough to support them. (Object oriented programming is not a panacea. It exacts a speed penalty over plain vanilla C or Fortran code, and often requires twice as much memory.)

Object oriented languages (OOP for short) included all the features of structured programming and added still more powerful ways to organize algorithms and data structures. There are three key features of OOP languages: encapsulation, polymorphism and inheritance. All of them are tied to the notion of a class.

Classes and Objects

The primary distinguishing feature of OOP languages is the class. A class is a data structure that can associate the methods which act on an object with the object itself. In pre-OOP languages methods and data were separate. In OOP languages they are all part of classes.

Programming languages provide a number of simple data types like int, float and String. However very often the data you want to work with may not be simple ints, floats or Strings. Classes let programmers define their own more complicated data types.

For instance let's suppose your program needs to keep a database of web sites. For each site you have a name, a URL, and a description. In traditional programming languages you'd have three different String variables for each web site. With a class you combine these into one package like so:

class website {

  String name;
  String url;
  String description;

}
These variables (name, url and description) are called the members of the class. They tell you what a class is and what its properties are. They are the nouns of the class.

In our web site database we will have many thousands of websites. Each specific web site is an object. The definition of a web site though, which we gave above, is a class. This is a very important distinction. A class defines what an object is, but it is not itself an object. An object is a specific instance of a class. Thus when we create a new object we say we are instantiating the object. Each class exists only once in a program, but there can be many thousands of objects that are instances of that class.

To instantiate an object in Java we use the new operator. Here's how we'd create a new web site:


    website x = new website();
Once we've got a website we want to know something about it. To get at the member variables of the website we can use the . operator. Website has three member variables, name, url and description, so x has three member variables as well, x.name, x.url and x.description. We can use these just like we'd use any other String variables. For instance:

    website x = new website();
    
    x.name = "Cafe Au Lait";
    x.url = "http://metalab.unc.edu/javafaq/";
    x.description = "Really cool!";
    
    System.out.println(x.name + " at " + x.url + " is " + x.description);
Methods

Data types aren't much use unless you can do things with them. For this purpose classes have methods. Members say what a class is. Methods say what a class does. For instance our website class might have a method to print its data. If so that would look like this:
class website {

  String name;
  String url;
  String description;
  
  print() {
    System.out.println(name + " at " + url + " is " + description);
  }

}
Outside the website method we call the print method just like we referenced the member variables, using the name of the particular object we want to print and the . operator.

    website x = new website();
    
    x.name = "Cafe Au Lait";
    x.url = "http://metalab.unc.edu/javafaq/";
    x.description = "Really cool!";
    
    x.print();
Notice that within the website class we don't need to use x.name or x.url. name and url are sufficient. That's because the print method must be called by a specific instance of the website class, and this instance knows what its data is. Or, another way of looking at it, the every object has its own print method.
The print() method is completely enclosed within the website class. All methods in Java must belong to a class. Unlike C++ programs, Java programs cannot have a method hanging around in global space that does everything you forgot to do in your classes.

Constructors

The first method most classes need is a constructor. A constructor creates a new instance of the class. It initializes all the variables and does any work necessary to prepare the class to be used. In the line website x = new website(); website() is a constructor. If no constructor exists Java provides a default one, but it's better to make sure you have your own. You make a constructor by writing a public method that has the same name as the class. Thus our website constructor is called website(). Here's a revised website class with a constructor that initializes all the members to null Strings.
class website {

  String name;
  String url;
  String description;
  
  public website() {
    name = ""; 
    url  = "";
    description = "";
  }

}
Better yet, we should create a constructor that accepts three Strings as arguments and uses those to initialize the member variables like so:
class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

}
We'd use this like so:

    website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!");
    x.print();
This fits in well with the goal of keeping code relevant to the proper functioning of a class within the class.
However what if sometimes when we want to create a web site we know the URL, name, and description, and sometimes we don't? Best of all, let's use both!

class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

  public website() {
    name = ""; 
    url  = "";
    description = "";
  }

}
This is called method overloading or polymorphism. Polymorphism is a feature of object oriented languages that lets one name refer to different methods depending on context. The important context is typically the number and type of arguments to the method. In this case we use the first version of the method if we have three String arguments and the second version if we don't have any arguments.
If you have one or two or four String arguments to the constructor, or arguments that aren't Strings, then the compiler generates an error because it doesn't have a method whose signature matches the requested method call.

toString Methods

Print methods are common in some languages but most Java programs operate differently. You can use System.out.println() to print any object. However for good results your class should have a toString() method that formats the objects data in a sensible way and returns a String. Here's how we'd implement it in the website example:
public class ClassTest {

  public static void main(String args[]) {
  
    website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!");
    System.out.println(x);
  
  }

}


class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

  public website() {
    name = ""; 
    url  = "";
    description = "";
  }
  
  public String toString() {
    return  (name + " at " + url + " is " + description);
  }

}
Some Advocacy

Unfortunately the object oriented language that took hold was C++. Among much fitter contenders for object languages, notably Smalltalk, C++ had the unique advantage of being downward compatible with the C programmers were already familiar with. Unfortunately this advantage had the huge side effect of forcing C++ to accept all of C's obfuscated macros, pointer arithmetic, and now redundant structs. The baggage imposed on C++ by the need to be compatible with C went a long way toward wiping out the advantage of object oriented programming.
Java is the latest and possibly the greatest third generation programming language. Here I need to explain why Java is a better OOP language than C++.

A Non-Trivial Examples: Complex Numbers

As mentioned in Chapter 2 one of the features needed for serious scientific computation is complex numbers. Unfortunately no popular computer language other than Fortran provides them as a built-in data type. (Actually this is such a common and useful example and was used by so many textbooks that it was recently added to the C++ standard library which makes it far less useful as an example. Fortunately, however, Java has not yet been around long enough to have all its really useful examples coopted into the standard library.) Let's see how we might implement them in Java. From the standpoint of a data type you really don't need much. Mathematically a complex number is composed of a real part u and an imaginary part v. We can create such a class in the following way:
public class ComplexNumber extends Object {

  public double u;
  public double v;

}
While this is sufficient to encompass all the data that one needs in a complex number it's not a very good example of object-oriented programming. To actually do anything with this number we have to know exactly how the data structure is defined. If we change the data structure, for instance by defining a complex number in terms of it's magnitude r and its argument theta instead of by its real and imaginary components we have to change all the code that depends on it.
We also have to write code to explicitly add the numbers, multiply them or do anything else we might need to do with complex numbers. If we need to add complex numbers in more than one place, then we need to write the addition code again, or, at the very least, copy and paste it.

A better implementation of a complex number class will shield us from the exact storage of the data, i.e. x and y vs. r and theta. It will also provide methods that let us perform any operation we might need to perform on or with a complex number.

Before writing code we need to ask ourselves what we'll do with a complex number. Most objects first require a constructor, a method that is called when you create a new complex number. A more complicated object may also require a destructor method that's called when you get rid of an object; but since this is a fairly simple object, we'll let Java's built-in garbage collection take care of that for us.

Since these are complex numbers it's not unlikely that we'll need to add them, subtract them, multiply them and divide them. We'll also want to be able to access their real and imaginary parts as well as their absolute values and arguments. The following class does all that.

//
public class Complex extends Object {

  private double u;
  private double v;

  Complex (double x, double y) {

    u=x;
    v=y;

  }

  public double Real () {

    return u;

  }

  public double Imaginary () {

    return v;

  }

  public double Magnitude () {

    return Math.sqrt(u*u + v*v);

  }

  public double Arg () {

    return Math.atan2(v, u);

  }

  // Add z to w; i.e. w += z
  public Complex Plus (Complex z) {

    
    return new Complex(u + z.u, v + z.v);

  }

  // Subtract z from w
  public Complex Minus (Complex z) {

    return new Complex(u - z.u, v - z.v);

  }

  public Complex Times (Complex z) {

    return new Complex(u*z.u - v*z.v, u*z.v + v*z.u);
    
  }


  // divide w by z
  public Complex DivideBy (Complex z) {

    double rz = z.Magnitude(); 

    return new Complex((u * z.u + v * z.v)/(rz*rz),(v * z.u - u * z.v)/(rz*rz));

  }

}
Notice especially that u and v are now private. They cannot be accessed by external code even if we want them to be.

The use of one of these methods will look like the following. Add the following ComplexExamples class to the Complex.java file and compile. Then run ComplexExamples in the usual way by typing java ComplexExamples.

//Complex Arithmetic Examples
class ComplexExamples  {

  public static void main (String args[]) {
  
    Complex u, v, w, z;

    u = new Complex(1,2);
    System.out.println("u: " + u.Real() + " + " + u.Imaginary() + "i");
    v = new Complex(3,-4.5);
    System.out.println("v: " + v.Real() + " + " + v.Imaginary() + "i");
    
    // Add u + v;
    z=u.Plus(v);
    System.out.println("u + v: "+ z.Real() + " + " + z.Imaginary() + "i");
    // Add v + u;
    z=v.Plus(u);
    System.out.println("v + u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.Minus(v);
    System.out.println("u - v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.Minus(u);
    System.out.println("v - u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.Times(v);
    System.out.println("u * v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.Times(u);
    System.out.println("v * u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.DivideBy(v);
    System.out.println("u / v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.DivideBy(u);
    System.out.println("v / u: "+ z.Real() + " + " + z.Imaginary() + "i");

  }

}
Exercises

What happens if we try to add a complex number to itself? e.g.

z = u.Add(u);
How about if we multiply, divide or subtract? e.g.

z = u.Multiply(u);
z = u.Divide(u);
z = u.Minus(u);
Rewrite the Complex class so that it stores its data as r and theta rather than u and v. Be sure to be careful at zero.
Add PlusEqual, MinusEqual, DivideEqual and MultiplyEqual methods to the Complex class that mimic the behavior of the +=, -=, *= and /= operators.
Add an equality method to the Complex class that tests whether two complex numbers are equal and returns a boolean.
For math whizzes only: Explain why it would not be a good idea to add less than or greater than methods to the Complex class.
For math whizzes only: Add a logarithm method to the Complex number class. Pick the branch between zero and 2pi.
For math whizzes only: Add a power method to the complex number class. This is straightforward for real powers. For a real challenge allow arbitrary complex powers. Be sure to consider how you'll deal with branch cuts.
toString Methods

Our printing in the last program was quite stilted because we needed to break a complex number into its real and imaginary parts, print them, and then put it all back together again. Wouldn't it be nice if we could just write:
System.out.println(u);

instead? It turns out we can. All objects have a toString method which is inherited from the Object class. However the default toString() method isn't very useful so we want to override it with one of our own creation that handles the conversion to complex numbers. Add the following method to the Complex class:

  public String toString() {
  
    if (v >= 0) return (String.valueOf(u) + " + " + String.valueOf(v) + "i");
    else return (String.valueOf(u) + " - " + String.valueOf(-v) + "i");
  }
You should also modify the ComplexExamples class as follows:


class ComplexExamples  {

  public static void main (String args[]) {
  
    Complex u, v, z;

    u = new Complex(1,2);
    System.out.println("u: " + u);
    v = new Complex(3,-4.5);
    System.out.println("v: " + v);
    
    // Add u + v;
    z=u.Plus(v);
    System.out.println("u + v: " + z);
    // Add v + u;
    z=v.Plus(u);
    System.out.println("v + u: " + z);


    z=u.Minus(v);
    System.out.println("u - v: " + z);
    z=v.Minus(u);
    System.out.println("v - u: " + z);

    z=u.Times(v);
    System.out.println("u * v: " + z);
    z=v.Times(u);
    System.out.println("v * u: "+ z);

    z=u.DivideBy(v);
    System.out.println("u / v: " + z);
    z=v.DivideBy(u);
    System.out.println("v / u: " + z);

  }
  
}
That's about an order of magnitude easier to understand and to write.

Polymorphism

So far our methods just do arithmetic on two complex numbers. It's not uncommon to want to multiply a complex number by a real number. To add this capability to our class we'll add the following method:

 
  public Complex Times (double x) {

    return new Complex(u*x, v*x);
    
  }
Here's a simple test program for your new method:


class RealComplex  {

  public static void main (String args[]) {
  
    Complex v, z;
    double x = 5.1;


    v = new Complex(3,-4.5);
    System.out.println("v: " + v);
    System.out.println("x: " + x);


    z=v.Times(x);
    System.out.println("v * x: " + z);


  }
  
}
The astute among you may be saying to hold on here, we've redefined the Times method. Now how can we multiply two complex numbers? However there's really no problem. The compiler notices that the arguments of the two methods named Times (not the same as the arguments of the two complex numbers but unfortunately the terminology fails us here) are different. One multiplies two complex numbers, the other multiplies a real number and a complex number. The compiler is smart enough to figure out which version of Times to use when. This is called method overloading or polymorphism.

In some object-oriented languages like C++ you can not only overload methods but even operators like + and =. However while this makes numeric classes like complex numbers easier to work with, it tends to lead to unreadable and unmaintainable code for non-numeric classes. Therefore Java's designers elected not to add this feature to the language. As you can see from our example, with a little forethought you really don't lose very much without operator overloading.

Exercises

Add a method to the Complex class that adds a real number to a complex number and returns a complex number.
Add methods for subtracting a real number from a complex number and for subtracting a complex number from a real. Be careful since subtraction, unlike addition, is not commutative.
Add methods for dividing a real by a complex number and for dividing a complex number by a real. Be careful since division, unlike multiplication, is not commutative.
Scope: Calling the Complex Class From External Classes

Until now we've stored almost every program in a single file. This becomes unwieldy as programs grow large. It becomes impossible to manage when more than one person is working on a program. It also loses out on one of the key benefits of OOP, code reusability. As long as all the code for a program is stored in one file, you can't reuse code except by cut and paste, just like in a non-object oriented language.

There has been some code that hasn't resided in our source files. Remember all those import statements at the top of every file? What they do is pull in prewritten and precompiled code from various locations so we can use it in our programs. You can do the same thing with classes you write. However to do this you do need to be aware of several conventions and restrictions.

No file should contain more than one public class. This means that our Hello World, Goodbye World example is no longer valid because each of the classes was public.
All files should have the same name as their single public class followed by the extension ".java".
Source code files should be stored in the same directory as their compiled .class file. This is so the Java compiler can find the appropriate definitions and interfaces for a class when the class is referred to in a different file.
Source code and .class files should be in a directory that's part of the $CLASSPATH environment variable.
We'll demonstrate this by splitting the example of the previous sections into two separate files, each of which contains one class. Begin by creating a file that contains the Complex class. (Your complex file may be a little different depending on how you answered the exercises in the previous sections.) Save this file as Complex.java.
Next save the examples from the previous exercises in a separate file called ComplexExamples.java in the same directory as Complex.java. Now compile both files and run Complex Examples.java.

The Mandelbrot Set

The Mandelbrot set is a classic application of complex arithmetic. It is the example of a fractal set.

Here and in the future we are going to try to separate the mathematical definition of our data from its display on the screen. In fact we won't even add the screen display till the second iteration of the program.

Our data structure will be a two dimensional array, each element of which represents a fixed point in the complex plane. The array is defined by the value of the lower left point, the gap between points and the number of pixels in the x and y directions. Thus given that element (0,0) of the array matches the complex point (x0,y0), each point is separated by a value gap, we know that element i,j of the array represents the point (x0 + i*gap, y0 + j*gap) in the complex plane. Since we know this by position of the array element alone we dont' need to store this value in the array.

What will we store in each element of this array? We'll calculate a number to go there in the following fashion. Let z = 0 + 0i and let c be the position of that array element in complex space. calculate z = z*z + c and iterate as follows up to 200 times:

for (i=0; i < 200; i++)  {
  z = z.Times(z) + c;
}
The Mandelbrot set is composed of those elements which, no matter how long we do this, never approach infinity. Since infinity can take a mighty long time to approach, it's fortunate that a fairly elementary theorem in complex variable theory guarantees that any number whose magnitude ever exceeds two in this iterative scheme will become as large as one might wish. (i.e. They asymptotically approach infinity.) Therefore once a number exceeds two we can break out of the loop and say definitively that this number is not in the Mandelbrot set.

Unfortunately there's no guarantee that just because an element doesn't reach 2 in two hundred iterations it might not reach two on the two hundredth and first iteration or the two thousandth or the two millionth. However most numbers that don't prove they're not in the Mandelbrot Set by the two hundredth iteration are reasonably likely to be in it.

Here's how the code will work. First we'll select the lower left hand corner of our rectangle in complex space, the size of the gap between the points and the number of points in each dimension. For a specific example we can choose the square bordered on the lower left by (-2,-2) and on the upper right by (2,2). To keep initial computations manageable we'll break this up into an array of 101 by 101 elements which implies a gap size of 0.05.

Once this array is created we'll loop through it and fill each element with a Boolean value, true if the element is probably in the Mandelbrot Set (doesn't pass two in two hundred iterations) and false if it's not (does pass two and thus go to infinity). Here's the code:


class MandelApp {

  public static void main(String args[]) {

    int xdim = 101;
    int ydim = 101;
    double xstart = -2.0;
    double ystart = -2.0;
    boolean Mandel[][] = new boolean[xdim][ydim];
    double gap = 0.05;
    int max_iterations = 200;
    int i,j,k;
    Complex z, c;

    for (i=0; i < xdim; i++) {
      for (j=0; j < ydim; j++) {

        c = new Complex(xstart + i*gap ,ystart + j*gap);
        z = new Complex(0.0, 0.0);
        k=0;
        while (z.Magnitude() < 2.0 && k < max_iterations) {
          z = z.Times(z);
          z = z.Plus(c);
          k++;
        }
        if (z.Magnitude() < 2.0) {
          Mandel[i][j] = true;
        }
        else Mandel[i][j] = false;
      }
    }
  
  }
}
Drawing the Mandelbrot Set

To make this interesting we want to actually draw pictures of the Mandelbrot Set. To do this we'll move the actual calculation into a thread in an applet and then draw the results into a bitmap. Here's the code:

import java.applet.Applet;
import java.awt.*;

public class Mandelbrot extends Applet {

  int xdim;
  int ydim;
  double xstart = -2.0;
  double ystart = -1.25;
  int Mandel[][];
  double gap = 0.05;
  int max_iterations = 256;

  
  public void paint(Graphics g) {
  
    int i,j,k;
    Complex z, c;
    
    xdim = size().width;
    ydim = size().height;
    gap = 2.5/ydim;
    Mandel = new int[xdim][ydim];
    
    for (i=0; i < xdim; i++) {
      for (j=0; j < ydim; j++) {
        c = new Complex(xstart + i*gap, ystart + j*gap);
        z = new Complex(0.0, 0.0);
        for (k = 0; z.Magnitude() < 2.0 && k < max_iterations; k++) {
          z = z.Times(z);
          z = z.Plus(c);
        }
        g.setColor(selectColor(k));
        g.fillRect(i, j, 1, 1);
      }
    }
  
  
  }
  
  
  protected Color selectColor (int num_iterations) {
  
    if (num_iterations > max_iterations) return Color.black;
    else if (num_iterations > 9*max_iterations/10) return Color.darkGray;
    else if (num_iterations > 8*max_iterations/10) return Color.gray;
    else if (num_iterations > 7*max_iterations/10) return Color.magenta;
    else if (num_iterations > 6*max_iterations/10) return Color.cyan;
    else if (num_iterations > 5*max_iterations/10) return Color.blue;
    else if (num_iterations > 4*max_iterations/10) return Color.green;
    else if (num_iterations > 3*max_iterations/10) return Color.yellow;
    else if (num_iterations > 2*max_iterations/10) return Color.orange;
    else if (num_iterations > 1*max_iterations/10) return Color.red;
    else return Color.white;
  
  }

}
This program is minimal. It should really create an ImageProducer which draws the Mandelbrot set. There are also a lot of additions that could be made to the parameters to allow for zooming in on particular regions. In fact you could even implement this as a Canvas in an applet with various controls to select the area of interest. This will all be investigated in the Cafe Au Lait newsletter.

For more details on the Mandelbrot Set see the first chapter of A.K. Dewdney's The Armchair Universe.

Exercises

Explore different starting points and gap sizes for the Mandelbrot set. To make this easier add user input to dynamically select the starting point and gap size.
What happens if you allow the x and y gap size to be chosen independently?
Acknowledgements

Noone ever truly writes a book alone. This tutorial relies heavily on Brian Kernighan and Dennis Ritchie's The C Programming Language, one of the alltime classics of computer language manuals.

The presentations at the first Java Day in New York City were crucial to getting my understanding of Java off the ground, especially those of Bill Joy and Frank Greco.

The eventtutor applet, flying lines applet and Mondrian applets are taken in spirit if not in code from Dave Mark and Cartwright Reed's Macintosh Programming Primer.

Finally I'd like to thank Olivia Whiteman, Dave Fisco, Tim Arnold and all the other Java Invaders for putting together forums in which I could learn more Java.

[ Cafe Au Lait | Books | Trade Shows | FAQ | Tutorial | User Groups ]
Copyright 1995-1998, 2000-2002, 2004-2006 Elliotte Rusty Harold 
elharo@metalab.unc.edu
Last Modified June 3, 2006